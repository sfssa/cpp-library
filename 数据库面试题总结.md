## **1、事务四大特性（ACID）原子性、一致性、隔离性、持久性？**

**原子性（Atomicity）**

**·** **原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚**，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

**一致性（Consistency）**

**·** **事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到**。

**隔离性（Isolation）**

**·** **隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离**。

同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

**持久性（Durability）**

**·** **持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作**。

## **2、事务的并发会造成什么问题？事务的隔离级别有哪些**

1. **脏读（Dirty Read）**：当一个事务读取了另一个事务未提交的数据，如果另一个事务在后续回滚，读取的数据可能是无效的。这是由于缺乏隔离性引起的。
2. **不可重复读（Non-Repeatable Read）**：在一个事务中，同一数据项的多次读取返回不同的值，这是因为其他事务已经修改了该数据项。
3. **幻象读（Phantom Read）**：在一个事务中，同一个查询的多次执行返回不同数量的记录，这是因为其他事务在事务执行期间插入或删除了记录。
4. **丢失更新（Lost Update）**：当两个事务同时读取一个数据项，然后同时尝试更新它，可能会导致其中一个事务的更新被覆盖，从而导致数据丢失。
5. **死锁（Deadlock）**：两个或多个事务相互等待对方释放锁的情况，导致所有事务无法继续执行。
6. **竞态条件（Race Condition）**：多个事务竞争访问共享资源，可能导致不确定的结果或数据损坏。
7. **并发控制问题**：并发控制问题包括数据的一致性问题，如读-写冲突、写-写冲突和读-读冲突，需要合适的并发控制机制（如锁或多版本控制）来解决。

事务的隔离级别是数据库管理系统中控制并发访问的一个重要概念。不同的隔离级别决定了事务在同时执行时看到其他事务的影响程度。常见的隔离级别包括以下四个级别，按照严格程度递增：

1. **Read Uncommitted（读未提交）**：在这个级别，事务可以读取其他事务尚未提交的未确认数据。这是最低级别的隔离，它可以导致脏读、不可重复读和幻象读。
2. **Read Committed（读已提交）**：在这个级别，事务只能读取已经提交的数据，不会读取未提交的数据。这可以避免脏读，但仍然可能遇到不可重复读和幻象读。
3. **Repeatable Read（可重复读）**：在这个级别，事务可以读取其他事务已提交的数据，但对于同一数据的多次读取将始终返回相同的结果，即不会出现不可重复读。但仍然可能出现幻象读。
4. **Serializable（可串行化）**：这是最高级别的隔离，它确保事务之间的完全隔离，避免了所有类型的并发问题，包括脏读、不可重复读和幻象读。通常，需要使用锁或其他机制来实现这一级别。

MySQL默认是可重复读。

## 3、什么是存储过程?

存储过程（Stored Procedure）是一种数据库对象，它是预先编写的一组SQL语句的集合，可以被存储在数据库中，以便重复使用。存储过程通常用于执行特定的数据库操作，如数据检索、数据更新、数据插入、数据删除等。

存储过程具有以下特点：

1. **封装性**：存储过程将一系列SQL语句封装在一个单独的单元中，隐藏了实现细节，只暴露接口供应用程序调用。
2. **可重用性**：存储过程可以在多个地方多次调用，从而避免了在不同应用程序或查询中重复编写相同的SQL语句。
3. **安全性**：存储过程可以控制访问权限，允许数据库管理员指定哪些用户或角色可以执行存储过程。
4. **性能**：存储过程可以在数据库服务器上进行预编译和优化，从而提高查询性能，减少数据传输开销。
5. **事务控制**：存储过程可以包含事务控制语句，从而实现事务的开始、提交和回滚。

存储过程通常使用SQL语言编写，可以包含条件、循环、参数、变量等编程元素，使其更加灵活和强大。它们在大型应用程序中常常用于数据操作、业务逻辑的封装和重用，以及确保数据的一致性和完整性。

## 4、索引是什么，有什么优点和缺点？

索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。

- 索引加快数据库的检索速度
- 索引降低了插入、删除、修改等维护任务的速度
- 唯一索引可以确保每一行数据的唯一性
- 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
- 索引需要占物理和数据空间

## 5、什么是事务？

事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。

## 6、乐观锁和悲观锁

乐观锁（Optimistic Locking）和悲观锁（Pessimistic Locking）是在并发编程和数据库管理中用于处理多个线程或进程之间共享资源的不同策略。它们的主要区别在于处理冲突的方式和对资源的乐观或悲观看法。

1. **乐观锁（Optimistic Locking）**：
   - 乐观锁假定在大多数情况下，资源不会被多个线程或进程同时修改，因此它不会立即锁定资源。
   - 当一个线程或进程想要修改资源时，它首先会读取资源的当前状态，然后在尝试更新资源之前检查资源的状态是否发生了变化。
   - 如果资源的状态没有发生变化，更新操作将继续，否则，资源的状态已被其他线程或进程修改，更新操作将被中止或重新尝试。
   - 乐观锁通常基于版本号（Versioning）或时间戳（Timestamp）来实现。每次资源发生变化时，版本号或时间戳都会增加。
2. **悲观锁（Pessimistic Locking）**：
   - 悲观锁假定在大多数情况下，资源可能被多个线程或进程同时修改，因此它在读取和修改资源时会立即锁定资源。
   - 当一个线程或进程需要访问资源时，它会请求锁定资源，如果资源已被锁定，则等待锁的释放。
   - 悲观锁确保在任何时刻只有一个线程或进程可以访问资源，从而避免了并发冲突。
   - 悲观锁通常使用数据库的行级锁或表级锁等机制来实现。

总结：

- 乐观锁适用于高度并发的情况，其中冲突发生的概率较低，因为它不会阻止其他线程或进程访问资源，只会在冲突时检测和处理。
- 悲观锁适用于资源竞争激烈的情况，其中冲突发生的概率较高，因为它会立即锁定资源，确保只有一个线程或进程可以访问资源。
- 选择乐观锁还是悲观锁取决于具体的应用场景和需求，以及对并发性能和数据一致性的权衡。

## 7、使用索引查询一定能提高查询的性能吗？为什么

通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.

索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:

- 基于一个范围的检索,一般查询返回结果集小于表中记录数的30%
- 基于非唯一性索引的检索

## 8、简单说一说**drop、delete**与**truncate**的区别

`DROP`、`DELETE` 和 `TRUNCATE` 是用于处理数据库表数据的不同 SQL 命令，它们有以下区别：

1. `DROP`：
   - `DROP` 用于删除整个数据库对象（如表、索引、视图等），而不是删除表中的数据。
   - 使用 `DROP` 后，表及其结构将完全被移除，不可恢复，需要谨慎使用。
2. `DELETE`：
   - `DELETE` 用于从表中删除特定的行或数据记录。
   - `DELETE` 可以使用带有 `WHERE` 子句的条件来过滤要删除的行，允许根据特定条件删除数据。
   - `DELETE` 操作是事务安全的，可以回滚（撤销）操作，且可以触发触发器（如果有）。
3. `TRUNCATE`：
   - `TRUNCATE` 用于删除表中的所有数据，但保留表的结构，包括列、索引、约束等。
   - `TRUNCATE` 不接受 `WHERE` 子句，无法根据条件删除部分数据，它总是删除整个表的数据。
   - `TRUNCATE` 操作通常比 `DELETE` 操作更快，因为它不会逐行删除，而是截断整个表。

总结：

- `DROP` 用于删除整个数据库对象。
- `DELETE` 用于删除表中的特定行。
- `TRUNCATE` 用于删除表中的所有数据，但保留表结构。

你的选择取决于你想要达到的效果。如果需要删除表的所有数据而保留表结构，可以使用 `TRUNCATE`。如果需要根据条件删除部分数据，使用 `DELETE`。如果需要删除整个表及其结构，使用 `DROP`。

## 9、 超键、候选键、主键、外键分别是什么？

1. **超键（Superkey）**：
   - 超键是能够唯一标识表中元组（行）的一组属性（列）的集合。这组属性可以包含多个列，而不一定是单个列。
   - 超键的属性集合可以包括多个候选键，也可以包括其他非唯一属性。
   - 示例：在一个包含学生信息的表中，{学生ID, 学生姓名} 是一个超键，因为它可以唯一标识每个学生。
2. **候选键（Candidate Key）**：
   - 候选键是表中的一组属性，可以唯一标识表中的每个元组（行）。
   - 候选键的属性集合是唯一的，没有重复的元组。
   - 表中可以有多个候选键，但通常选择一个作为主键。
   - 示例：在学生信息表中，{学生ID} 是一个候选键，因为它可以唯一标识每个学生，没有重复的学生ID。
3. **主键（Primary Key）**：
   - 主键是从候选键中选择的一个，用于唯一标识表中的每个元组。
   - 主键属性集合在表中是唯一的，没有重复的元组。
   - 表中只能有一个主键。
   - 示例：在学生信息表中，{学生ID} 被选择为主键，用于唯一标识每个学生。
4. **外键（Foreign Key）**：
   - 外键是一个表中的列，与另一个表的主键或候选键相关联，用于维护表之间的关系。
   - 外键确保参照表中的数据一致性，以便只能引用已经存在的值。
   - 示例：在一个学生选课表中，学生ID列可以作为外键，引用学生信息表中的学生ID作为参照。

总结：

- 超键是一个可以唯一标识表中元组的属性集合。
- 候选键是表中的属性集合，可以唯一标识表中的元组，可以有多个候选键。
- 主键是从候选键中选择的，用于唯一标识表中的元组，每个表只有一个主键。
- 外键是一个与其他表的主键或候选键相关联的列，用于维护表之间的关系。

## 10、什么是视图？以及视图的使用场景有哪些？

视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改一般不影响基本表。（在满足某种条件是会影响）它使得我们获取数据更容易，相比多表查询。

- 只暴露部分字段给访问者，所以就建一个虚表，就是视图。
- 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异

## 11、介绍三个范式

数据库设计中的三个范式，通常称为第一范式（1NF）、第二范式（2NF）和第三范式（3NF），是用来规范数据库表结构，以减少数据冗余和提高数据一致性的规则。

1. **第一范式（1NF）**：
   - 1NF 要求数据库表的每一列都包含原子数据，也就是不可再分的数据。每个列的值必须是单一的，不可再分的。
   - 例如，一个包含学生信息的表，每一列应包含单一的信息，如学生的姓名、学号、出生日期，而不是将多个信息合并到一列中。
2. **第二范式（2NF）**：
   - 2NF 要求表必须首先符合 1NF，并且表中的非主键列必须完全依赖于候选键。
   - 2NF 通常涉及到具有复合主键的表，它要求非主键列不仅要依赖于整个主键，还要依赖于主键的每一部分。
   - 例如，一个订单表具有复合主键（订单号和产品编号），产品名称依赖于产品编号，而不依赖于订单号。
3. **第三范式（3NF）**：
   - 3NF 要求表必须首先符合 2NF，且表中的非主键列之间不应该存在传递依赖。
   - 3NF 通过消除非主键列之间的传递依赖来减少数据冗余。传递依赖意味着非主键列之间存在间接的依赖关系。
   - 例如，一个包含雇员信息的表，如果雇员的工资依赖于雇员的部门，而部门依赖于部门经理，那么工资与雇员之间存在传递依赖。

示例： 考虑一个订单管理系统的数据库，包含以下两个表：

**订单表（Orders）**：

- 订单号（OrderID，主键）
- 顾客ID（CustomerID）
- 顾客姓名（CustomerName）
- 产品ID（ProductID）
- 产品名称（ProductName）
- 产品单价（ProductPrice）

**产品表（Products）**：

- 产品ID（ProductID，主键）
- 产品名称（ProductName）
- 产品描述（ProductDescription）

在这个示例中，如果我们应用三个范式：

1. 第一范式（1NF）：确保每列包含原子数据。
   - 订单表和产品表都满足 1NF，每列包含原子数据。
2. 第二范式（2NF）：非主键列依赖于整个候选键。
   - 订单表中，产品名称依赖于产品ID，但不依赖于订单号。这违反了 2NF。解决方法是将产品名称移动到产品表中，以依赖于整个候选键（ProductID）。
3. 第三范式（3NF）：消除传递依赖。
   - 假设产品描述（ProductDescription）依赖于产品名称，而不依赖于产品ID。这违反了 3NF。解决方法是将产品描述从产品表中移除，以创建一个独立的产品描述表，并使用产品ID作为外键来关联产品描述。这样，传递依赖被消除。

通过遵循这些范式，数据库设计变得更加规范，减少了数据冗余和提高了数据一致性。

## 12、MySQL跨表查询几种方式？

在MySQL中，进行跨表查询的主要方式包括以下几种：

1. **JOIN 操作**：使用JOIN操作是最常见的进行跨表查询的方式。MySQL支持不同类型的JOIN，包括INNER JOIN（内连接）、LEFT JOIN（左连接或外连接）、RIGHT JOIN（右连接或外连接）和FULL JOIN（全连接）。通过在查询中使用JOIN操作，可以将多个表连接在一起，以便同时查询它们的数据。

   示例：

   ```
   sqlCopy codeSELECT customers.name, orders.order_date
   FROM customers
   INNER JOIN orders ON customers.customer_id = orders.customer_id;
   ```

2. **子查询**：子查询是一种在查询中嵌套的查询，可以用来检索与外部查询相关的数据。通过子查询，可以在一个查询中引用另一个表的数据。

   示例：

   ```
   sqlCopy codeSELECT name
   FROM customers
   WHERE customer_id IN (SELECT customer_id FROM orders WHERE order_date = '2023-01-01');
   ```

3. **UNION 操作**：UNION操作用于合并两个或多个SELECT语句的结果集。这可以用于从不同的表中检索数据并将它们合并成一个结果集。

   示例：

   ```
   sqlCopy codeSELECT name FROM customers
   UNION
   SELECT product_name FROM products;
   ```

4. **嵌套查询**：嵌套查询是在一个SELECT语句中嵌套另一个SELECT语句，允许在一个查询中引用其他表的数据。

   示例：

   ```
   sqlCopy codeSELECT name, (SELECT MAX(order_date) FROM orders WHERE customer_id = customers.customer_id) AS last_order_date
   FROM customers;
   ```

5. **视图**：视图是一个虚拟表，可以基于一个或多个源表创建。通过创建视图，你可以将多个表的数据组合在一起，并对视图执行查询，而不必直接查询源表。

   示例（创建视图）：

   ```
   sqlCopy codeCREATE VIEW customer_orders AS
   SELECT customers.name, orders.order_date
   FROM customers
   INNER JOIN orders ON customers.customer_id = orders.customer_id;
   ```

   示例（查询视图）：

   ```
   sqlCopy codeSELECT name, order_date
   FROM customer_orders;
   ```

这些方式可以根据具体的需求和查询复杂度选择。JOIN操作通常是最常用的方式，但其他方式也在不同场景中发挥作用。

## 13、inner join，left join、right join什么区别

`INNER JOIN`、`LEFT JOIN` 和 `RIGHT JOIN` 是 SQL 中用于连接表的不同类型的 JOIN 操作，它们之间的主要区别在于连接的方式和保留的行。以下是它们的区别：

1. **INNER JOIN**：

   - INNER JOIN 返回两个表中匹配行的交集。只有在连接条件成立的情况下，才会包括在结果集中。
   - 如果没有匹配的行，不会包括在结果中。
   - INNER JOIN 通常用于获取两个表中共同的数据。

   示例：

   ```
   sqlCopy codeSELECT customers.name, orders.order_date
   FROM customers
   INNER JOIN orders ON customers.customer_id = orders.customer_id;
   ```

2. **LEFT JOIN**：

   - LEFT JOIN 返回左表中的所有行以及右表中与左表中的行匹配的行。如果没有匹配的行，右表的列将包含 NULL 值。
   - 左表的所有行都会包括在结果集中，而右表中没有匹配的行将用 NULL 值填充。

   示例：

   ```
   sqlCopy codeSELECT customers.name, orders.order_date
   FROM customers
   LEFT JOIN orders ON customers.customer_id = orders.customer_id;
   ```

3. **RIGHT JOIN**：

   - RIGHT JOIN 与 LEFT JOIN 类似，但返回右表中的所有行以及左表中与右表中的行匹配的行。如果没有匹配的行，左表的列将包含 NULL 值。
   - 右表的所有行都会包括在结果集中，而左表中没有匹配的行将用 NULL 值填充。

   示例：

   ```
   sqlCopy codeSELECT customers.name, orders.order_date
   FROM customers
   RIGHT JOIN orders ON customers.customer_id = orders.customer_id;
   ```

总结：INNER JOIN 返回匹配的行，LEFT JOIN 返回左表的所有行和匹配的右表行（包括 NULL 值），RIGHT JOIN 返回右表的所有行和匹配的左表行（包括 NULL 值）。选择使用哪种类型的 JOIN 取决于你需要的结果以及你希望如何处理没有匹配的行。

## 14、mylsam、innodb的区别

1.InnoDB和MyISAM都是B+数的结构。

2.InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REPETABLE READ （可重复读），并且通过间隙锁策略防止幻读的出现。

3.InnoDB表是基于聚簇索引建立的。

4.InnoDB支持事务。

5.InnoDB具有自动崩溃恢复功能。

6.InnoDB支持外键。

MyISAM

1.MyISAM 不支持事务和行级锁。

2.崩溃后无法安全恢复。

3.对于只读的数据，或者表比较小，可以忍受修复操作的可以使用。

4.MyISAM会将表存储在两个文件中，数据文件和索引文件，分别以.MYD和.MYI为扩展名。

5.MyISAM 支持全文索引。

|                                                              | **MyISAM**                                                   | **Innodb**                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存储结构                                                     | 每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件 | 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB |
| 存储空间                                                     | MyISAM可被压缩，存储空间较小                                 | InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引 |
| 可移植性、备份及恢复                                         | 由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作 | 免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了 |
| 文件格式                                                     | 数据和索引是分别存储的，数据.MYD，索引.MYI                   | 数据和索引是集中存储的，.ibd                                 |
| 记录存储顺序                                                 | 按记录插入顺序保存                                           | 按主键大小有序插入                                           |
| 外键                                                         | 不支持                                                       | 支持                                                         |
| 事务                                                         | 不支持                                                       | 支持                                                         |
| 锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的） | 表级锁定                                                     | 行级锁定、表级锁定，锁定力度小并发能力高                     |
| SELECT                                                       | MyISAM更优                                                   |                                                              |
| INSERT、UPDATE、DELETE                                       |                                                              | InnoDB更优                                                   |
| select count(*)                                              | myisam更快，因为myisam内部维护了一个计数器，可以直接调取。   |                                                              |
| 索引的实现方式                                               | B+树索引，myisam 是堆表                                      | B+树索引，Innodb 是索引组织表                                |
| 哈希索引                                                     | 不支持                                                       | 支持                                                         |
| 全文索引                                                     | 支持                                                         | 不支持                                                       |

## 15、说说你了解的MySQL慢查询？

MySQL的慢查询是一种性能分析工具，用于帮助识别执行速度较慢的SQL查询语句。慢查询通常用于优化数据库性能，找出潜在的性能问题并采取措施来改善查询的执行效率。

以下是关于MySQL慢查询的一些重要信息：

1. **什么是慢查询**：
   - 慢查询是指执行时间超过一定阈值（通常以秒为单位）的SQL查询语句。
   - 阈值通常由数据库管理员或开发人员根据具体情况设置。
2. **慢查询日志**：
   - MySQL允许启用慢查询日志，将慢查询的详细信息记录到日志文件中。
   - 这些日志包括查询的执行时间、执行日期和时间、扫描的行数、所影响的行数等信息。
3. **慢查询分析**：
   - 通过慢查询日志，你可以分析哪些查询需要优化。
   - 可以使用工具或手动分析日志文件，识别性能较差的查询。
4. **优化查询**：
   - 一旦识别出慢查询，可以采取多种方式来优化它们，例如重写查询、添加索引、优化数据库结构等。
   - 优化后的查询将具有更快的执行时间。
5. **EXPLAIN命令**：
   - MySQL提供了`EXPLAIN`命令，用于分析查询执行计划。
   - 通过`EXPLAIN`，你可以查看MySQL如何执行查询，包括表的访问顺序、使用的索引、连接类型等。
6. **慢查询工具**：
   - 除了手动分析日志，还有许多工具可用于监控和分析慢查询。
   - 这些工具可以提供可视化的性能分析和建议。
7. **定期监控**：
   - 为了持续维护数据库性能，定期监控慢查询是很重要的。
   - 定期分析慢查询可以帮助你识别性能问题并采取适当的措施来改善查询性能。

## 16、redis支持的数据类型

Redis支持多种数据类型，这些数据类型使其成为一个非常灵活的内存数据库。以下是Redis支持的主要数据类型：

1. **字符串（String）**：字符串是最基本的数据类型，可以存储文本、二进制数据等。Redis支持字符串的读写、追加等操作。
2. **哈希表（Hash）**：哈希表用于存储字段和与字段关联的值。它类似于关联数组或字典，适合存储对象的属性。
3. **列表（List）**：列表是有序的字符串元素集合，允许在两端进行插入和删除操作。它可用于实现队列、栈等数据结构。
4. **集合（Set）**：集合是无序的字符串元素集合，不允许重复元素。它支持集合操作，如交集、并集和差集。
5. **有序集合（Sorted Set）**：有序集合与集合类似，但每个元素关联一个分数，用于排序元素。它适合实现排行榜、范围查询等功能。
6. **位图（Bitmap）**：位图是一种紧凑的数据结构，可用于存储二进制位信息，支持位操作，如设置、清除和计数。
7. **超级日志（HyperLogLog）**：超级日志是一种用于估计独立元素数量的数据结构。它适合用于统计唯一访客数等场景。
8. **地理空间索引（Geospatial Index）**：Redis支持地理空间数据类型，用于存储地理位置信息，并支持空间查询操作。

## 17、redis为什么这么快？ 高并发如何处理的？

Redis之所以如此快速，主要是因为它采用了以下一些关键技术和设计原则：

1. **内存存储**：Redis将数据存储在内存中，这使得数据的读取和写入速度非常快，因为内存的访问速度远远快于磁盘。
2. **单线程模型**：Redis采用单线程模型，这意味着它使用了一个主线程来处理所有客户端请求。单线程可以避免多线程之间的锁竞争，使得Redis在不涉及复杂计算的情况下可以实现高吞吐量。
3. **非阻塞I/O**：Redis使用非阻塞I/O操作，通过异步操作来提高处理请求的效率。这使得Redis能够同时处理多个客户端请求而不会被阻塞。
4. **数据结构优化**：Redis使用了高效的数据结构，如哈希表、跳表等，这些数据结构在查找、插入和删除操作上具有高效性能。
5. **持久化选项**：Redis支持多种持久化方式，包括快照（Snapshot）和追加文件（Append-Only File），这些持久化方式可以根据需要进行配置，以在数据丢失的情况下进行恢复。

对于高并发处理，Redis采用了以下策略：

1. **连接池**：Redis使用连接池来管理客户端连接，减少了每个请求都建立和关闭连接的开销。
2. **多路复用**：Redis采用了多路复用技术，可以同时处理多个客户端请求，而不需要为每个请求创建一个新线程。
3. **分片（Sharding）**：Redis支持数据分片，可以将数据分布在多个Redis实例中，以处理大规模并发。
4. **主从复制**：通过主从复制，Redis可以将读取请求分发到多个从服务器，从而提高读取操作的性能。
5. **使用缓存**：Redis通常用作缓存，可以减轻后端数据库的负担，从而提高整体性能。

总之，Redis的高性能和高并发处理能力是通过内存存储、非阻塞I/O、单线程模型和高效数据结构等多种技术和设计原则的综合应用实现的。这使得Redis成为一种强大的内存数据库，适用于处理高并发读写请求的应用场景。

## 18、为什么redis采用单线程的设计？

因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。

在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。

## 19、过期键的删除策略有哪些？

1. 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
2. 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
3. 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

## 20、内存淘汰策略

主要有以下六种方案：

 **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

 **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 

**volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

 **allkeys-lru**：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 

**allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰

 **no-enviction**（驱逐）：禁止驱逐数据，新写入操作会报错 

## 21、缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存击穿、缓存降级了解吗？

### **缓存雪崩**

缓存雪崩指的是缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

我们可以简单的理解为：由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。

**解决办法**

- 事前：尽量保证整个 Redis 集群的高可用性，发现机器宕机尽快补上，选择合适的内存淘汰策略。
- 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉， 通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
- 事后：利用 Redis 持久化机制保存的数据尽快恢复缓存

### **缓存穿透**

一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量 请求而崩掉。

缓存穿透是指查询一个一定不存在的数据，由于缓存不命中，接着查询数据库也无法查询出结果，因此也不会写入到缓存中，这将会导致每个查询都会去请求数据库，造成缓存穿透。

**解决办法**

1、**布隆过滤器**

这是最常见的一种解决方法了，它是将所有可能存在的数据哈希到一个足够大的**bitmap**中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压 力。

对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；

这里稍微科普一下布隆过滤器。

> 布隆过滤器是引入了k(k>1)k(k>1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。
>
> 该算法的**核心思想**就是利用多个不同的Hash函数来解决“冲突”。Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是布隆过滤器的基本思想，一般用于在大数据量的集合中判定某元素是否存在。

2、**缓存空对象**

当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；如果一个**查询返回的数据为空**（不管是数据不存 在，还是系统故障），我们仍然把这个空结果进行缓存，但它的**过期时间会很短**，最长不超过五分钟。

但是这种方法会存在两个问题：

1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；

2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。

我们可以从适用场景和维护成本两方面对这两汇总方法进行一个**简单比较**：

**适用场景**：缓存空对象适用于1、数据命中不高 2、数据频繁变化且实时性较高 ；而布隆过滤器适用1、数据命中不高 2、数据相对固定即实时性较低

**维护成本**：缓存空对象的方法适合1、代码维护简单 2、需要较多的缓存空间 3、数据会出现不一致的现象；布隆过滤器适合 1、代码维护较复杂 2、缓存空间要少一些

**缓存预热**

缓存预热是指系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户会直接查询事先被预热的缓存数据！

**解决思路** 1、直接写个缓存刷新页面，上线时手工操作下； 2、数据量不大，可以在项目启动的时候自动进行加载； 3、定时刷新缓存；

### **缓存更新**

除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：**定时删除和惰性删除**，其中： （1）定时删除：定时去清理过期的缓存； （2）惰性删除：当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。

### **缓存击穿**

缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

比如常见的电商项目中，某些货物成为“爆款”了，可以对一些主打商品的缓存直接设置为永不过期。即便某些商品自己发酵成了爆款，也是直接设为永不过期就好了。mutex key互斥锁基本上是用不上的，有个词叫做大道至简。

**缓存降级**

当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。 降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。 以参考日志级别设置预案： （1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级； （2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警； （3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级； （4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。

缓存降级是指在系统资源有限或缓存失效时，临时放弃缓存而直接访问数据库或其他数据源，以确保系统继续运行而不会因无法获取缓存数据而崩溃。缓存降级是一种牺牲一定性能或数据的可用性来保证系统整体可用性和稳定性的策略。

以下是一个具体的例子来说明缓存降级：

假设你正在构建一个电子商务网站，网站上有一个商品详情页，该页面需要从数据库中检索商品的详细信息。为了提高性能，你决定在商品详情页的第一次访问时将商品信息存储在缓存中，这样后续的访问可以快速获取。

但是，如果在某个时刻数据库压力增大，数据库响应时间变长，或者缓存服务器发生故障，那么从缓存中获取商品信息可能会失败，因为缓存中可能没有相关数据。在这种情况下，你可以实施缓存降级策略，以确保页面继续提供服务而不崩溃。

缓存降级的策略可以包括：

1. **使用默认数据**：如果无法获取缓存数据，可以在页面上显示默认数据，以确保页面继续提供价值。
2. **延迟加载**：在第一次请求时不强制加载缓存，而是允许较长的加载时间。这样，后续的请求可以从缓存中获得数据。
3. **返回错误信息**：在某些情况下，可以返回错误信息，通知用户商品信息不可用，但不要导致页面崩溃。
4. **限制页面元素**：在无法获取数据时，可以限制页面上的某些元素或功能，以减轻数据库负载。

缓存降级策略的目标是保持系统的可用性和稳定性，即使在缓存不可用的情况下也能继续提供服务。这是特别重要的，因为依赖于缓存的系统在某些情况下可能会面临缓存数据不一致或不可用的问题。

## 22、如何保证缓存与数据库的双写一致性？

你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题。

最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，**先更新数据库，然后再删除缓存**。

**为什么是删除缓存，而不是更新缓存？**

原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。

比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。

另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于**比较复杂的缓存数据计算的场景**，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，**这个缓存到底会不会被频繁访问到？**

举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有**大量的冷数据**。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。**用到缓存才去算缓存。**

其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都把里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。

## 23、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？

要从Redis中找出以某个固定前缀开头的所有键，你可以使用Redis的SCAN命令结合匹配模式。在这种情况下，你可以执行以下步骤：

1. 使用SCAN命令迭代查找匹配的键。
2. 使用匹配模式来指定前缀。例如，如果你的前缀是"prefix_"，你可以使用匹配模式"prefix_*"。
3. 在每次迭代中，SCAN命令会返回一批匹配的键，你可以将这些键保存起来。
4. 继续迭代，直到遍历完所有键。