# vector 详解

## 概述

vector的数据安排和操作方式与array非常相似，两者唯一区别在于空间的运用的灵活性。array是静态空间，一旦配置了就不能改变；要换个大一点的空间需要客户自己实现下面的操作：

- 寻找一块新的足够大的空间；
- 将旧的元素拷贝到新的空间；
- 将原来的空间还给系统。

vector是动态空间，随着元素的加入，内部机制会自行扩充以容纳新的元素，因此vector的运用对于内存的合理利用与运用的灵活性有很大帮助。

## 数据结构

vector所采用的数据结构非常简单：线性连续空间，以两个迭代器start和finish分别指向配置得来的连续空间中目前已使用的范围，用迭代器end_of_storage指向整块连续空间的尾部。

```c++
template <class T,class Alloc=alloc>
class vector
{
...
protected:
    iterator start;					//目前使用空间的头
    iterator finish;				//目前使用空间的尾
    iterator end_of_storage;		//目前可用空间的尾
...
}
```

为了降低空间配置时的时间速度，vector实际配置的大小可能比客户端要求更大一些，以备将来可能的扩充。换句话说，一个vector的容量永远大于等于其大小。

![image-20230929220052261](C:\Users\16645\AppData\Roaming\Typora\typora-user-images\image-20230929220052261.png)

## 动态扩充

所谓动态增加大小，并不是在原空间之后接续新空间，这是由于无法保证原空间之后尚有可供配置的空间，而是以1.5/2背另外配置一块较大的空间，然后将旧的数据拷贝到新的空间，并释放原空间。因此，一旦引起空间重新配置，指向原vector的迭代器就都失效了。