# 一面

## C++中堆和栈的区别

1. 存储方式：
   - **栈（Stack）**：栈是一种线性数据结构，以后进先出（LIFO）的方式存储数据。它用于存储局部变量和函数调用的上下文信息。栈的管理通常由编程语言的运行时系统自动处理，你无需手动分配或释放栈上的内存。
   - **堆（Heap）**：堆是一种树状数据结构，没有固定的存取规则，数据可以随时插入、删除。堆通常用于存储动态分配的内存，例如通过`new`和`delete`或`malloc`和`free`函数分配的内存。在堆上的内存需要手动管理，确保在不再需要时释放它，以避免内存泄漏。
2. 生命周期：
   - **栈**：栈上的数据通常具有较短的生命周期，它们的生命周期与包含它们的函数调用相关。当函数返回时，函数内部的局部变量被自动销毁。
   - **堆**：堆上的数据可以具有较长的生命周期，它们的生命周期不受函数调用的限制。你需要手动分配和释放堆上的内存，否则内存泄漏可能会发生。
3. 访问速度：
   - **栈**：由于栈上的数据通常位于物理内存中较接近的位置，所以访问速度更快。
   - **堆**：堆上的数据分布较为散乱，访问速度相对较慢。
4. 分配方式：
   - **栈**：栈内存的分配和释放由编程语言的编译器和运行时系统自动处理，通常是按照固定的模式分配，因此速度更快。
   - **堆**：堆内存的分配和释放需要手动操作，通常需要一些系统调用，较慢。

## 指针和引用的区别

1. 指针是一个变量，它保存了另一个变量的内存地址；引用是另一个变量的别名，与原变量共享内存地址。

2. 指针可以被重新赋值，指向不同的变量；引用在初始化后不能更改，始终指向同一个变量。

3. 指针可以为 nullptr，表示不指向任何变量；引用必须绑定到一个变量，不能为 nullptr。

4. 使用指针需要对其进行解引用以获取或修改其指向的变量的值；引用可以直接使用，无需解引用。
5. sizeof运算符作用于指针变量得到指针变量自身大小；作用于引用，得到引用所指向的变量的大小。
6. 指针可以有多级，引用只有一级。
7. 从汇编语言上来说，引用会被c++编译器当做const指针来进行操作，可以看作编译器自动完成取地址、解引用的指针常量

## 指针数组和数组指针

**指针数组**:

- 指针数组是一个数组，其中的每个元素都是指针。这些指针可以指向不同的数据或对象。
- 每个元素指向一个单独的数据或对象，因此它们可以具有不同的类型。

```
int* ptrArray[3];  // 声明一个包含 3 个整型指针的指针数组
```

**数组指针**:

- 数组指针是一个指针，它指向一个数组。数组可以包含相同类型的元素，但指针指向整个数组而不是单个元素。
- 数组指针通常用于处理多维数组，它们指向数组的起始地址。

```
int (*arrPtr)[3];  // 声明一个指向包含 3 个整数的数组的指针
```

## 指针常量和常量指针

1. **指针常量 (Pointer to a Constant)**:
   - 指针常量是一个指针，它指向的是一个常量对象，也就是说，通过该指针不能修改所指向的对象的值。
   - 声明指针常量时，使用 `const` 修饰指针本身，表示指针是常量，但不表示所指向的对象是常量。
   - 示例：`int const* ptr;` 表示 `ptr` 是一个指向常量整数的指针，即不能通过 `ptr` 修改整数的值，但可以让 `ptr` 指向不同的整数。
2. **常量指针 (Constant Pointer)**:
   - 常量指针是一个指针，它不能指向不同的对象，也就是说，一旦指向了一个对象，就无法再通过该指针修改所指向对象的值。
   - 声明常量指针时，使用 `const` 修饰指针指向的对象，表示所指向的对象是常量，但不表示指针本身是常量。
   - 示例：`int* const ptr;` 表示 `ptr` 是一个常量指针，即它指向的整数是常量，无法通过 `ptr` 修改整数的值，但可以确保 `ptr` 不会指向其他整数。

## static的作用

1. **静态变量 (Static Variables)**:
   - 在函数内部声明的静态变量会保留其值，即使函数执行完毕，该变量的值也会保持不变。这对于跟踪某些状态或计数在多次函数调用之间是有用的。
   - 在全局作用域中声明的静态变量只在当前文件中可见，其他文件无法访问它，这有助于实现信息的封装。
2. **静态函数 (Static Functions)**:
   - 静态函数在 C/C++ 中具有内部链接 (internal linkage)，它们只在当前文件中可见，无法在其他文件中调用。这有助于将函数的实现细节隐藏在文件内部，提高了代码的模块化性。
3. **静态成员 (Static Members)**:
   - 在 C++ 中的类中，静态成员变量和静态成员函数与类的实例无关，它们属于类本身，而不是类的实例。这允许多个类的实例共享相同的静态成员。
   - 静态成员变量在多个类的实例之间共享状态，静态成员函数可以访问静态成员变量而不需要类的实例。
4. **静态方法 (Static Methods)**:
   - 在许多编程语言中，静态方法属于类而不属于类的实例。它们不需要类的实例来调用，并且通常用于执行与类本身相关的操作。
5. **静态常量 (Static Constants)**:
   - 在 C/C++ 中，`const` 关键字与 `static` 结合使用可创建静态常量，这些常量在程序的整个生命周期内保持不变。
6. **访问权限**
   - 静态函数可以访问静态函数和静态成员而无法直接访问非静态成员函数和非静态成员变量。这是由于静态成员函数和变量服务整个类，没有this指针，成员函数和成员变量都是通过实例对象的this指针来访问的，而静态函数并没有this指针，因此无法访问。但反过来可以。

## 静态变量什么时候初始化

**文件作用域静态变量（全局静态变量）**：

- 在全局作用域中声明的静态变量（在函数外部声明的静态变量）在程序启动时自动初始化。它们的值在整个程序生命周期内保持不变，直到程序终止。
- 全局静态变量的初始化在程序启动时进行，即在 `main` 函数执行之前。如果没有显式指定初始值，全局静态变量会被初始化为零或适当的默认值，具体取决于数据类型。

**局部作用域静态变量**：

- 在函数内部声明的静态变量也称为局部静态变量。这些变量在第一次遇到声明它们的代码行时初始化，而不是在每次函数调用时初始化。
- 局部静态变量的初始化仅在第一次函数调用时进行，之后的函数调用会保留变量的值。它们的生命周期延伸到整个程序运行期间。

## unordered_map是如何实现的，开链法和扩容

1. **哈希表实现**：
   - `std::unordered_map` 使用哈希表来存储键-值对。哈希表是一个数组，每个元素称为桶（bucket）。每个桶可以存储一个或多个键-值对。
   - 为了确定一个键应该存储在哪个桶中，哈希表使用哈希函数，它将键映射到桶的索引。
   - 哈希冲突是指多个键具有相同的哈希值，通常发生在不同的键被哈希到同一个桶的情况下。
2. **开链法**：
   - `std::unordered_map` 使用开链法来处理哈希冲突。在开链法中，每个桶都是一个链表或其他数据结构，用于存储具有相同哈希值的键-值对。
   - 当发生哈希冲突时，新的键-值对被添加到对应桶的链表中。如果多个键具有相同的哈希值，它们都存储在同一个桶中，每个桶维护一个链表，用于存储所有键-值对。
   - 链表中节点超过8就切换成红黑树。
3. **扩容**：
   - 为了保持哈希表的性能，当负载因子达到一定阈值时，`std::unordered_map` 会自动进行扩容。负载因子是已存储键-值对数目与桶的总数目之比。
   - 扩容过程涉及创建一个更大的哈希表，通常是原哈希表大小的两倍。然后，已存在的键-值对被重新哈希到新的桶中，以确保它们在新哈希表中分布更均匀。
   - 扩容是一个开销较大的操作，但它有助于保持哈希表的性能，因为它减少了哈希冲突的可能性。

## vector迭代器如何实现的

没有迭代器时，访问不同的容器会有不同的代码，可读性和可理解性较差，于是产生了迭代器。迭代器是类模板实现的，利用了模板的偏特化，表现得像指针，使得能够以相同的代码访问不同的容器。迭代器返回的是对象引用而不是对象的值，且使用后就自动释放了。

## Linux下进程调度算法，Linux选用的哪一种

Linux采用多种进程调度算法，其中最常见的是CFS（Completely Fair Scheduler）。下面是有关Linux进程调度的一些基本信息：

1. **CFS（Completely Fair Scheduler）**：

   - CFS使用红黑树结构，来存储要调度的任务队列。

   - 每个节点代表了一个要调度的任务，节点的key即为虚拟时间（vruntime），虚拟时间由这个任务的运行时间计算而来。

   -  key越小，也就是vruntime越小的话，红黑树对应的节点就越靠左。vruntime并不是无限小的，有一个最小值来限定。假如新进程的vruntime初值为0的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占CPU的优势，老进程就要饿死了，这显然是不公平的。

     CFS是这样做的：每个CPU的运行队列cfs_rq都维护一个min_vruntime字段，记录该运行队列中所有进程的vruntime最小值，新进程的初始vruntime值就以它所在运行队列的min_vruntime为基础来设置，与老进程保持在合理的差距范围内。

   - **CFS scheduler每次都挑选最左边的节点作为下一个要运行的任务，**这个节点是“缓存的”——由一个特殊的指针指向；不需要进行O（logn）遍历来查找。也因此，CFS搜索的时间是O(1)。

2. **实时调度**：

   - 除了CFS，Linux还支持实时进程调度。Linux中有两种实时调度策略：SCHED_FIFO和SCHED_RR。
   - SCHED_FIFO允许一个实时进程一直运行，直到它自愿放弃CPU。
   - SCHED_RR是一个轮转调度算法，实时进程按照优先级轮流获取CPU时间片。

3. **CFS的优势**：

   - CFS被广泛使用，因为它提供了公平的CPU时间分配，适用于大多数通用用途的计算机系统。
   - CFS的设计使得它能够适应多核处理器和多任务环境。

## 进程调度算法

**1、 先来先服务 first-come first-serverd（FCFS）**

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

**2、 短作业优先 shortest job first（SJF）**

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

**3、最短剩余时间优先 shortest remaining time next（SRTN）**

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。

如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

**4、时间片轮转**

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。

当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

**5、优先级调度**

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

**6、多级反馈队列**

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。

这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

## 切换线程的过程

1. **中断或系统调用触发**：
   - 线程切换通常由中断、系统调用或时间片用完等事件触发。操作系统会响应这些事件，并开始执行线程切换。
2. **保存当前线程上下文**：
   - 操作系统首先保存当前运行线程的上下文信息，包括寄存器状态、程序计数器、堆栈指针和其他相关信息。
   - 这些信息保存在内存中的线程控制块（Thread Control Block，TCB）中。
3. **选择下一个线程**：
   - 操作系统选择要切换到的下一个线程。这通常是根据调度算法来确定的，例如先来先服务（FIFO）、优先级、时间片轮转等。
4. **加载下一个线程的上下文**：
   - 操作系统从下一个线程的TCB中恢复其上下文信息，包括寄存器状态、程序计数器、堆栈指针等。
5. **切换内存空间**（可能）：
   - 如果线程之间的内存空间隔离（例如，多进程环境），操作系统可能需要切换内存页表或虚拟内存映射以确保下一个线程能够正确访问其内存空间。
6. **启动下一个线程**：
   - 恢复的线程的上下文后，操作系统开始执行下一个线程，从其上次停止的地方继续执行。
7. **完成线程切换**：
   - 线程切换完成，新的线程开始执行，旧线程的上下文被保存在TCB中，以备稍后再次切换回该线程。

## 切换进程的过程

1. **中断或系统调用触发**：
   - 进程切换通常由中断、系统调用、时钟中断或其他事件触发。操作系统会响应这些事件，开始执行进程切换。
2. **保存当前进程的上下文**：
   - 操作系统首先保存当前运行进程的上下文信息，包括寄存器状态、程序计数器、堆栈指针和其他相关信息。
   - 这些信息保存在进程控制块（Process Control Block，PCB）中。
3. **选择下一个进程**：
   - 操作系统选择要切换到的下一个进程。这通常是根据调度算法来确定的，例如先来先服务（FIFO）、优先级、时间片轮转等。
4. **加载下一个进程的上下文**：
   - 操作系统从下一个进程的PCB中恢复其上下文信息，包括寄存器状态、程序计数器、堆栈指针等。
5. **切换内存空间**：
   - 如果进程之间的内存空间隔离（例如，多进程环境），操作系统可能需要切换内存页表或虚拟内存映射以确保下一个进程能够正确访问其内存空间。
6. **启动下一个进程**：
   - 恢复的进程的上下文后，操作系统开始执行下一个进程，从其上次停止的地方继续执行。
7. **完成进程切换**：
   - 进程切换完成，新的进程开始执行，旧进程的上下文被保存在PCB中，以备稍后再次切换回该进程。

## 线程独占的资源

在一个进程内，每个线程的私有资源包括寄存器、程序计数器、栈空间以及线程局部存储（Thread-Local Storage，TLS）。除了这些基本的线程私有资源，还有一些其他资源和属性，如下所示：

1. **线程控制块（TCB）**：每个线程都有一个独立的线程控制块，其中包含了线程的状态信息、标识符、优先级、线程局部存储索引等。TCB用于操作系统管理和控制线程。
2. **线程局部存储（TLS）**：TLS允许线程存储和访问线程私有的数据，对其他线程不可见。每个线程可以在TLS中维护自己的数据，这些数据对其他线程是独立的。
3. **堆栈**：每个线程都有自己的堆栈空间，用于保存局部变量、函数调用信息和线程执行状态。堆栈是线程私有的，不同线程之间的堆栈是相互独立的。
4. **程序计数器**：程序计数器存储了当前线程执行的指令位置，是线程私有的，因此不同线程有不同的程序计数器。
5. **寄存器**：每个线程拥有一组寄存器，包括通用寄存器和特定于架构的寄存器。这些寄存器用于执行线程的指令和维护线程状态。
6. **信号掩码**：每个线程可以有自己的信号掩码，用于控制哪些信号会被传递到线程。不同线程可以有不同的信号处理策略。
7. **线程局部存储（TLS）索引**：每个线程可以访问TLS中的数据，TLS索引用于确定线程在TLS中的数据位置。
8. **线程特定数据（Thread-Specific Data，TSD）**：线程可以拥有自己的线程特定数据，这些数据是线程私有的，并且在线程结束时会自动销毁。

## 线程的实现方式

**C++ 标准库中的 `std::thread`**：

- `std::thread` 是 C++11 标准引入的线程类，用于创建和管理线程。
- 它是面向对象的线程库，提供了丰富的线程操作接口，可以直接创建线程对象，并使用成员函数来管理线程。
- `std::thread` 是 C++ 标准库的一部分，因此在支持 C++11 及以上标准的编译器中可用。

```
#include <thread>
std::thread myThread(func); // 创建线程对象
```

**POSIX 线程（`pthread_t`）**：

- `pthread_t` 是 POSIX 线程库的一部分，用于创建和管理线程。
- 它是 C 标准库的一部分，提供了基本的线程操作接口，通常需要使用 `pthread_create` 等函数来创建线程。
- `pthread_t` 不是面向对象的，它更加底层，通常需要结合其他 POSIX 线程库函数来使用。

```
#include <pthread.h>
pthread_t myThread;
pthread_create(&myThread, NULL, func, NULL); // 创建线程
```

## 如何实现线程同步

1. **互斥锁（Mutex）**：
   - 互斥锁是最常见的线程同步工具，用于保护临界区（多个线程不能同时访问的共享资源）。
   - 通过在临界区周围加锁和解锁操作，确保只有一个线程可以进入临界区。
   - 在C++中，你可以使用 `std::mutex`，在C语言中，你可以使用 `pthread_mutex_t`。
2. **条件变量（Condition Variables）**：
   - 条件变量用于线程之间的通信，允许一个线程等待另一个线程满足特定条件。
   - 一个线程可以等待条件变量的状态，而另一个线程可以在某些条件下通知等待线程。
   - 在C++中，你可以使用 `std::condition_variable`，在C语言中，你可以使用 `pthread_cond_t`。
3. **信号量（Semaphore）**：
   - 信号量是一种计数器，用于控制同时访问共享资源的线程数量。
   - 信号量可以用来限制并发线程的数量或者实现生产者-消费者问题等。
   - 在C++中，你可以使用 `std::counting_semaphore`（C++20起）或第三方库，如 Boost 中的信号量。
4. **自旋锁（Spin Lock）**：
   - 自旋锁是一种互斥锁，不会使线程进入休眠状态，而是在一直尝试获取锁。
   - 自旋锁适用于对临界区的访问时间非常短的情况。
   - 在C++中，你可以使用 `std::atomic_flag` 实现自旋锁。
5. **屏障（Barrier）**：
   - 屏障用于同步多个线程，要求它们在特定点等待，直到所有线程都到达该点。
   - 屏障通常用于分阶段执行任务的情况，确保所有线程都完成了当前阶段才能继续下一阶段。
   - 在C++中，你可以使用 `std::barrier`（C++20起）或使用第三方库，如 Boost 中的屏障。
6. **原子操作（Atomic Operations）**：
   - 原子操作是在单个操作中完成的，不会被其他线程中断。这些操作可用于更新共享资源，而不需要额外的锁。
   - C++标准库提供了一系列原子类型（例如 `std::atomic`）和原子操作函数（例如 `std::atomic::load` 和 `std::atomic::store`）。
7. **读-写锁（Read-Write Lock）**：
   - 读-写锁允许多个线程同时读取共享资源，但只允许一个线程写入资源。
   - 这对于具有多读者和少写者的场景非常有用，可以提高并发性。
   - 在C++中，你可以使用 `std::shared_mutex`（C++17起）。

## 上锁来访问临界资源的步骤

1. **创建锁对象**：首先，创建一个互斥锁对象。在C++中，你可以使用 `std::mutex`，在C语言中，你可以使用 `pthread_mutex_t`。
2. **加锁**：在进入临界区之前，线程需要尝试获取锁，这通常使用互斥锁的 `lock` 或 `pthread_mutex_lock` 操作来完成。如果锁已经被其他线程占用，线程将被阻塞，直到锁可用。
3. **访问临界资源**：一旦线程成功获得锁，它可以安全地访问临界资源，执行所需的操作。
4. **解锁**：在退出临界区之后，线程必须释放锁，以便其他线程可以获得访问权限。这通常使用互斥锁的 `unlock` 或 `pthread_mutex_unlock` 操作来完成。

## Linux服务器上cpu100%了如何定位问题

1. **使用 `top` 或 `htop` 命令**：
   - 打开终端，运行 `top` 或 `htop` 命令，查看当前的进程和它们的CPU占用情况。
   - 这些命令将显示运行中的进程，并按CPU占用率进行排序，可以帮助你找到哪些进程占用了大量CPU。
2. **查看具体进程**：
   - 在 `top` 或 `htop` 中，你可以找到占用CPU最多的进程的名称和进程ID（PID）。
   - 使用 `ps` 命令，例如 `ps aux | grep <PID>`，查看特定进程的详细信息，包括进程的启动参数、执行路径等。
3. **查看日志文件**：
   - 检查系统日志文件，如 `/var/log/syslog` 或 `/var/log/messages`，以查找任何异常或错误消息，可能会提供有关CPU占用率高的原因的线索。
4. **使用 `strace` 和 `lsof`**：
   - `strace` 用于跟踪进程的系统调用，可以帮助你了解进程正在执行什么操作。例如，`strace -p <PID>` 可以跟踪特定进程。
   - `lsof` 用于查看打开文件的进程，可能会帮助你找到与CPU占用高相关的文件或套接字。
5. **检查应用程序日志**：
   - 如果问题与特定应用程序相关，查看应用程序的日志文件，以查找有关错误或异常的信息。
6. **性能分析工具**：
   - 使用性能分析工具如 `perf`、`strace`、`gprof`、`Valgrind` 等，可以更详细地分析进程的性能特征和调用堆栈。
7. **监控工具**：
   - 使用系统监控工具如 `sar`、`vmstat`、`iostat` 等，可以监视CPU、内存、磁盘等资源的使用情况，并生成历史性能数据，帮助你分析性能趋势。
8. **资源限制**：
   - 如果一个进程占用了大量CPU，并导致系统负载过高，可以使用工具如 `ulimit` 或 `cgroups` 来限制该进程的资源使用。
9. **升级和优化**：
   - 考虑升级硬件或优化代码，以提高系统性能并降低CPU占用。
10. **查找恶意软件**：
    - 在某些情况下，高CPU占用可能是由恶意软件引起的。使用杀毒软件和恶意软件扫描工具来检查系统。

## 服务器监听的过程

1. **导入必要的库**：
   - 在你的代码中包含与网络编程相关的头文件，如 `<sys/socket.h>`、`<netinet/in.h>` 和 `<arpa/inet.h>`（在C中）或 `<Winsock2.h>`（在Windows中）。
2. **创建套接字**：
   - 使用 `socket()` 函数创建一个套接字，指定地址族（IPv4或IPv6）、套接字类型（TCP或UDP）以及协议（通常为0，表示默认协议）。
3. **绑定套接字**：
   - 使用 `bind()` 函数将套接字绑定到服务器的IP地址和端口号。这将告诉操作系统在哪里监听连接请求。
4. **监听连接**（仅适用于TCP服务器）：
   - 对于TCP服务器，使用 `listen()` 函数开始监听连接请求。指定允许排队的连接请求数。
5. **接受连接**（仅适用于TCP服务器）：
   - 使用 `accept()` 函数接受客户端的连接请求。这将创建一个新的套接字，用于与客户端通信。
6. **处理连接**：
   - 处理客户端发送的数据或请求，可以根据你的应用程序的需求进行处理。
7. **关闭连接**：
   - 使用 `close()` 函数关闭与客户端的连接。如果服务器要继续监听其他客户端的连接，可以返回第5步。
8. **关闭套接字**：
   - 当服务器不再需要监听或通信时，使用 `close()` 函数关闭服务器的套接字。

## 服务器的半连接队列和全连接队列

在理解半连接队列和全连接队列之前，需要先了解一下TCP的三次握手和四次挥手过程。

**TCP的三次握手过程**：

1. 客户端向服务器发送一个SYN（同步）包，请求建立连接。
2. 服务器收到SYN包后，回复一个SYN-ACK（同步-确认）包，表示接受连接。
3. 客户端收到服务器的SYN-ACK包后，发送一个ACK（确认）包，完成连接的建立。

**TCP的四次挥手过程**：

1. 客户端发送一个FIN（结束）包，表示不再发送数据。
2. 服务器收到客户端的FIN包后，发送一个ACK包，确认收到FIN包。
3. 服务器发送一个FIN包，表示服务器也不再发送数据。
4. 客户端收到服务器的FIN包后，发送一个ACK包，完成连接的关闭。

**半连接队列（SYN队列）**： 半连接队列用于存放处于TCP三次握手过程中的连接请求。当客户端发送SYN包请求建立连接时，服务器将其放入半连接队列。一旦服务器发送了SYN-ACK包，将移至全连接队列。

**全连接队列**： 全连接队列用于存放已经建立连接的套接字。一旦完成TCP三次握手，连接将从半连接队列移到全连接队列，表示连接已经建立，可以开始数据传输。

在高并发的情况下，半连接队列和全连接队列的大小是需要调整和优化的参数。半连接队列过大可能会导致资源浪费，而过小可能会拒绝一些连接请求。全连接队列的大小决定了服务器可以同时处理的已建立连接的数量。

通常，系统管理员可以通过调整操作系统的参数来配置半连接队列和全连接队列的大小，以满足服务器的需求。不同操作系统和网络库可能具有不同的默认值和配置方法。

## HTTP和HTTPS的区别

1. **安全性**：
   - HTTP是不安全的，它的数据传输是明文的，容易被中间人攻击截取和窃听。因此，HTTP在传输敏感信息时不安全。
   - HTTPS通过使用SSL/TLS协议加密数据传输，使数据在传输过程中加密，确保数据的机密性和完整性。因此，HTTPS在传输敏感信息时更加安全。
2. **端口**：
   - HTTP默认使用端口80进行通信。
   - HTTPS默认使用端口443进行通信。
3. **协议**：
   - HTTP使用明文文本进行通信，请求和响应的内容都是可读的。
   - HTTPS使用SSL/TLS协议对数据进行加密，使数据在传输过程中无法轻易解读。
4. **证书**：
   - HTTPS需要使用数字证书，通常由受信任的证书颁发机构（CA）颁发，用于验证服务器的身份。这有助于防止中间人攻击。
   - HTTP不涉及证书验证，因此没有身份验证机制，容易受到中间人攻击的威胁。
5. **搜索引擎排名**：
   - 搜索引擎通常会更喜欢在搜索结果中显示使用HTTPS的网站，因为它们提供了更好的安全性和隐私保护。这可能会影响网站的搜索引擎排名。

## HTTPS连接过程

1. **握手协议**：
   - 客户端向服务器发送一个客户端Hello消息，其中包含支持的加密算法和其他信息。
   - 服务器收到客户端Hello后，选择一个加密算法，生成一个服务器Hello消息，其中包含选择的加密算法和服务器证书。
   - 服务器还会生成一个随机数作为密钥，然后使用公钥将其加密，并将其发送给客户端。
   - 服务器的证书包含服务器的公钥，用于客户端后续的数据加密。
2. **客户端验证服务器证书**：
   - 客户端收到服务器的Hello消息后，会验证服务器的证书。它会检查证书的有效性，包括证书是否由受信任的证书颁发机构（CA）签发，是否没有过期等。
   - 如果验证通过，客户端会生成一个随机数作为会话密钥，并使用服务器的公钥将其加密，然后发送给服务器。
3. **密钥协商**：
   - 服务器收到客户端的会话密钥后，使用私钥进行解密，获取会话密钥。
   - 现在客户端和服务器都拥有了相同的会话密钥，用于后续的数据加密和解密。
4. **加密通信**：
   - 客户端和服务器使用协商好的会话密钥进行通信。数据在传输过程中被加密，保护了数据的隐私和完整性。
5. **数据传输**：
   - 客户端和服务器之间的数据传输是经过加密保护的，使其对中间人攻击不易受到威胁。
6. **关闭连接**：
   - 客户端和服务器之间的连接可以通过完成四次挥手过程来关闭连接，以确保数据传输的完整性。

## 一个TCP站点连接数的限制

**client最大tcp连接数**

client每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他tcp连接共享。tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，一个client最大tcp连接数为65535，这些连接可以连到不同的serverip。

**server最大tcp连接数**

server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此server端tcp连接4元组中只有remoteip（也就是clientip）和remote port（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。

## 服务器端如何辨别客户端的访问是同一个人

常用是文件描述符   cookie   Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。

1. **用户登录和会话管理**：
   - 要跟踪用户是否是同一个人，通常需要要求用户登录并分配一个唯一的会话标识符（Session ID）。
   - 服务器可以在用户登录后为其分配一个会话ID，然后将该ID存储在Cookie中或通过URL参数传递到客户端。客户端将在后续的请求中返回该会话ID。
   - 通过检查会话ID，服务器可以确定请求是否来自同一个已登录用户。
2. **IP地址追踪**：
   - 服务器可以追踪访问者的IP地址。虽然IP地址不是唯一的用户标识，但在某些情况下可以用来识别用户。
   - 请注意，同一家庭或公司的多个用户可能共享相同的公共IP地址。
3. **浏览器指纹识别**：
   - 浏览器指纹是一种识别用户的技术，它基于浏览器的特性和配置。浏览器指纹可以包括浏览器类型、版本、操作系统、屏幕分辨率等信息。
   - 尽管不是百分之百准确，但浏览器指纹可以用于辨别用户，尤其是在没有登录的情况下。
4. **Cookie跟踪**：
   - 使用Cookie来存储用户的标识信息是常见的做法。服务器可以在Cookie中存储唯一的标识符，以便在用户不登录的情况下辨别用户。
   - 请注意，用户可以删除Cookie或禁用Cookie，因此这不是绝对可靠的方法。
5. **OAuth和第三方身份验证**：
   - 使用OAuth等身份验证协议和第三方身份验证提供商（如Google、Facebook）进行用户身份验证和跟踪是一种常见的方法。
   - 服务器可以使用第三方提供的唯一标识符来辨别用户。
6. **行为分析**：
   - 通过分析用户的访问行为、交互模式和使用模式，服务器可以尝试辨别是否是同一个用户。

## mysql的索引方式

1. **B-Tree 索引**：B-Tree（平衡树）索引是 MySQL 中最常见的索引类型。它适用于各种查询，并且可以用于精确匹配、范围查询和排序操作。B-Tree 索引在数据插入、删除和更新时效率较高。
2. **哈希索引**：哈希索引适用于等值查找操作，但不支持范围查询或排序。哈希索引对于某些特定的查询非常高效，但不适用于所有情况。
3. **全文索引**：全文索引用于全文搜索，通常与文本数据一起使用。它允许进行全文搜索和匹配文本中的关键字。MySQL的全文索引通常用于InnoDB存储引擎。
4. **空间索引**：空间索引用于存储具有地理空间坐标的数据，允许进行地理位置相关的查询，如距离计算等。
5. **前缀索引**：前缀索引是对列值的前几个字符进行索引，而不是整个列。这可以节省存储空间并提高查询性能，尤其是对于长文本字段。
6. **复合索引**：复合索引是将多个列组合在一起创建的索引。它可以用于多列的查询条件，以提高性能。
7. **唯一索引**：唯一索引要求所有索引值都是唯一的，通常用于确保数据表中某一列的唯一性，例如主键。
8. **主键索引**：主键索引是一种唯一索引，用于唯一标识数据表中的每行记录。
9. **外键索引**：外键索引用于建立表之间的关系。外键通常指向另一个表的主键，并用于维护数据完整性。
10. **自定义索引**：除了上述常见的索引类型，MySQL还支持创建自定义索引，以满足特定的查询需求。这可以通过存储过程和函数实现。

## 不同索引使用的底层数据结构

1. **B-Tree 索引**：
   - **底层数据结构**：B-Tree（平衡树）是最常见的索引数据结构。它是一种自平衡的树结构，用于存储有序的索引键和对应的行指针。B-Tree 索引支持范围查询和排序，并在插入和删除操作时保持平衡。
2. **哈希索引**：
   - **底层数据结构**：哈希索引使用哈希表作为底层数据结构。哈希表使用哈希函数将索引键映射到一个桶（bucket），每个桶中包含一个链表或其他数据结构，用于存储哈希冲突的键。哈希索引对于等值查询非常高效，但不支持范围查询或排序。
3. **全文索引**：
   - **底层数据结构**：全文索引使用倒排索引（Inverted Index）作为底层数据结构。倒排索引存储每个文档中出现的单词（词项）和对应的文档标识符。全文索引允许快速定位包含特定关键字的文档。
4. **空间索引**：
   - **底层数据结构**：空间索引使用R树（R-Tree）或其变体作为底层数据结构。R树是一种多维索引结构，用于存储地理坐标和空间对象的信息。它支持范围查询和距离计算。
5. **前缀索引**：
   - **底层数据结构**：前缀索引仍使用B-Tree，但只存储索引键的前缀部分，而不是完整键。这可以减小索引的大小，提高查询性能。
6. **唯一索引**：
   - **底层数据结构**：唯一索引可以使用B-Tree或哈希表，具体取决于数据库管理系统的实现。其目标是确保索引键的唯一性。
7. **主键索引**：
   - **底层数据结构**：主键索引通常使用B-Tree，确保数据表中每行记录的主键值是唯一的。
8. **外键索引**：
   - **底层数据结构**：外键索引也可以使用B-Tree或其他适当的数据结构。它用于建立表之间的关系，通常是引用另一个表的主键。
9. **自定义索引**：
   - 自定义索引的底层数据结构取决于用户自定义的索引实现。这可以包括各种数据结构，根据特定需求选择合适的数据结构。

## sql中索引失效的场景

**未使用索引列**：当查询条件中未使用索引列时，索引会失效。例如，如果存在一个列上的索引，但查询中没有使用该列作为过滤条件，索引将不起作用。

```
-- 索引失效，因为没有使用索引列
SELECT name FROM users WHERE age > 30;
```

**使用函数或表达式**：在查询条件中使用函数、操作符或表达式，使得无法直接使用索引进行匹配。

```
-- 索引失效，因为对索引列进行了函数操作
SELECT id FROM products WHERE UPPER(name) = 'PRODUCT_NAME';
`WHERE UPPER(column) = 'VALUE'` 或 `WHERE column + 1 = 5`。
```

**数据分布不均匀**：如果索引列的数据分布不均匀，即某些值的出现频率极高，而其他值很少出现，索引可能会失效。这种情况下，数据库优化器可能选择不使用索引，因为全表扫描更快。

假设有一个城市表，其中有一个索引列 `population`，但有一座城市的人口极高，其他城市的人口很少。如果查询所有人口大于100,000的城市，索引可能失效。

```
-- 索引可能失效，因为数据分布不均匀
SELECT city_name FROM cities WHERE population > 100000;
```

**对索引列进行了类型转换**：如果在查询中对索引列进行了类型转换，例如将字符串转为数字，索引将失效。

```
-- 索引失效，因为对索引列进行了类型转换
SELECT username FROM users WHERE CAST(id AS VARCHAR) = '123';
```

**OR条件**：在查询中使用了OR条件，而每个OR条件中的列没有单独的索引。这种情况下，数据库可能无法有效地使用索引。

```
-- 索引可能失效，因为使用了OR条件
SELECT product_id FROM inventory WHERE location = 'A' OR location = 'B';
```

**联合索引的顺序**：如果存在多列的联合索引，而查询条件中的列顺序与索引的顺序不匹配，索引可能会失效。

```
如果索引是 (last_name, first_name)，那么查询中应该按照相同的顺序使用这两个列。以下是一些示例，展示了匹配和不匹配的情况：
-- 索引匹配，按顺序使用索引列
SELECT * FROM employees WHERE last_name = 'Smith' AND first_name = 'John';

-- 索引不匹配，与索引列的顺序不一致
SELECT * FROM employees WHERE first_name = 'John' AND last_name = 'Smith';

```

**数据量过大**：如果表中的数据量非常大，而查询结果集占据大部分数据，数据库可能会选择不使用索引，而执行全表扫描。

```
-- 索引可能失效，因为查询结果集占据大部分数据
SELECT description FROM products WHERE price < 10;
```

## 组合索引如何匹配

组合索引是指在一个索引中包含多个列，而不仅仅是单个列。匹配组合索引的关键是按照索引的列顺序提供查询条件，以确保索引能够有效利用。

**匹配左侧前缀**：当查询中包含组合索引的左侧列，索引可以有效使用。

```
-- 组合索引有效匹配，因为包含了左侧列
SELECT * FROM my_table WHERE column1 = 'value1';
```

**匹配左侧前缀和部分右侧列**：查询中可以包含组合索引的左侧列和部分右侧列，索引仍然有效。

```
-- 组合索引有效匹配，因为包含了左侧列和部分右侧列
SELECT * FROM my_table WHERE column1 = 'value1' AND column2 = 'value2';
```

**不匹配左侧前缀**：如果查询中未包含组合索引的左侧列，索引可能不会被使用。

```
-- 组合索引可能不会有效匹配，因为未包含左侧列
SELECT * FROM my_table WHERE column2 = 'value2';
```

## 什么是覆盖索引

覆盖索引（Covering Index）是一种特殊类型的数据库索引，它包含了除索引列之外的其他查询所需的列数据。具体来说，覆盖索引包括了满足查询需求的列，因此不需要回表（Table Lookups）到实际数据行来获取额外信息。

覆盖索引的主要特点包括：

1. **包含查询所需列**：覆盖索引包含了除索引列之外的其他列数据，这些列通常是查询的选择列或过滤条件。
2. **减少磁盘和内存访问**：由于覆盖索引包含了必要的数据，查询可以直接从索引中获取信息，而不需要额外的磁盘或内存访问。这可以显著提高查询性能。
3. **减少I/O成本**：覆盖索引可以减少I/O成本，因为不需要回表到实际数据行。这对于大型数据库和复杂查询尤其有益。
4. **提高查询性能**：通过减少不必要的数据检索和处理，覆盖索引可以大幅提高查询性能，尤其是对于频繁执行的查询。

## mysql中的锁：行锁，间隙锁，表锁

1. **行级锁（Row-Level Lock）**：
   - 行级锁是最细粒度的锁，它允许不同事务同时锁定同一表中的不同行。
   - 行级锁通常用于读取或修改表中的部分数据，而不会锁定整个表。
   - 行级锁可以避免锁定不相关的数据，提高了并发性，但也可能导致死锁问题。
2. **间隙锁（Gap Lock）**：
   - 间隙锁是为了防止幻读（Phantom Read）而引入的一种锁。
   - 当一个事务在满足某个条件的数据行之间插入新数据时，MySQL会自动为满足条件的范围引入间隙锁，以阻止其他事务在该范围内插入数据。
   - 间隙锁可以防止其他事务的插入操作干扰当前事务的一致性，但也可能对性能产生一定影响。
3. **表级锁（Table-Level Lock）**：
   - 表级锁是最粗粒度的锁，它锁定整个表，阻止其他事务访问该表的任何行。
   - 表级锁通常用于管理整个表的结构，例如创建、删除或修改表的操作。
   - 表级锁通常会引起较大的并发性问题，因为多个事务无法同时访问同一表。

## ACID的实现原理是什么

1. **原子性（Atomicity）**：原子性要求事务是不可分割的单元，要么全部执行成功，要么全部失败。实现原理包括事务日志（Transaction Log）和事务管理。数据库在执行事务时会生成事务日志，记录所有操作，以便在事务失败时进行回滚。事务管理器负责跟踪事务的状态，确保它们要么完全提交，要么完全回滚。
2. **一致性（Consistency）**：一致性要求事务将数据库从一个一致状态转移到另一个一致状态，不会破坏数据的完整性。实现原理包括数据完整性约束、触发器和事务控制。数据库会应用数据完整性约束（如唯一性约束、外键约束）来保证数据的一致性。触发器可以在数据修改时执行额外的操作，以维护一致性。事务控制机制确保在事务中的操作要么全部成功，要么全部失败，以保持一致性。
3. **隔离性（Isolation）**：隔离性确保并发执行的事务不会互相干扰，每个事务似乎在独立运行。实现原理包括锁定机制、多版本控制和事务隔离级别。数据库使用锁定机制来防止多个事务同时修改相同的数据，从而确保隔离性。多版本控制允许事务在不阻塞其他事务的情况下读取数据的先前版本。事务隔离级别（如读未提交、读已提交、可重复读、串行化）定义了事务之间的隔离程度。
4. **持久性（Durability）**：持久性要求一旦事务提交，其结果应该永久保存，即使系统崩溃也不会丢失。实现原理包括事务日志和数据写入策略。数据库通过事务日志记录每个事务的操作，以便在系统崩溃后进行恢复。数据写入策略确保数据写入到持久存储介质（如硬盘）而不是内存，以确保持久性。

## 隔离级别

1. **读未提交（Read Uncommitted）**：在这个隔离级别下，一个事务可以读取另一个事务尚未提交的数据修改。这意味着可能会出现脏读（Dirty Read），即读取到未提交的、未经验证的数据。这是最低级的隔离级别，通常不建议使用，因为它牺牲了数据的一致性。
2. **读已提交（Read Committed）**：在这个隔离级别下，事务只能读取已经提交的数据修改。这消除了脏读的问题，但仍然允许不可重复读和幻读。不可重复读是指一个事务在多次读取同一行数据时，得到的结果可能不一致。幻读是指一个事务在多次查询时，得到的结果集可能不一致。
3. **可重复读（Repeatable Read）**：在这个隔离级别下，事务可以多次读取相同的数据，而不会看到其他事务的修改。这消除了不可重复读的问题，但仍然允许幻读。幻读是由于其他事务插入新数据行或删除现有数据行导致的。可重复读隔离级别通常是许多数据库系统的默认级别。
4. **串行化（Serializable）**：这是最高级别的隔离级别，它确保事务之间的完全隔离，不允许脏读、不可重复读和幻读。在串行化级别下，事务必须顺序执行，没有并发执行，以确保数据的一致性。这是最安全的隔离级别，但也是性能开销最大的。

## 可重复读是如何实现的

"可重复读"是事务隔离级别中的一种，它的主要特点是事务在读取数据时不会看到其他事务对同一数据的修改，即多次读取相同数据会得到一致的结果。在MySQL中，可重复读是通过多版本并发控制（MVCC）来实现的。

以下是MySQL中实现可重复读隔离级别的一般步骤：

1. **版本号控制**：每行数据都会关联一个版本号（或者说是事务ID），用来标识数据的修改历史。这个版本号在数据被插入或更新时自动记录。
2. **事务开始**：当一个事务开始时，MySQL会为该事务分配一个唯一的事务ID。这个ID用来标识该事务对数据的读取和修改。
3. **读取数据**：在可重复读隔离级别下，事务读取数据时，只会看到版本号小于或等于该事务ID的数据版本。这确保了事务不会看到其他事务对同一数据的未提交修改。
4. **写入数据**：当事务更新数据时，MySQL会为新的数据行创建一个新版本，同时保留旧版本。这确保了其他事务仍然可以读取旧版本的数据，直到该事务提交。
5. **提交事务**：当事务提交时，它的事务ID会被标记为已提交。这意味着其他事务在读取数据时将不再看到该事务对数据的修改。

通过以上机制，可重复读隔离级别下的事务能够实现多次读取相同数据而得到一致的结果，同时不会看到其他事务对数据的未提交修改。

## 主从同步如何实现

主从同步（Master-Slave Replication）是数据库系统中常用的一种数据复制技术，用于将主数据库的数据复制到一个或多个从数据库，以实现数据备份、负载均衡、高可用性和数据分发等目的。下面是主从同步的基本实现方式：

1. **配置主数据库**：
   - 在主数据库服务器上启用二进制日志（Binary Log），这个日志记录了主数据库上的数据更改操作，如插入、更新、删除等。
   - 配置一个唯一的标识符（通常是server-id）来标识主数据库。
2. **配置从数据库**：
   - 在从数据库服务器上配置连接到主数据库的信息，包括主数据库的地址、用户名、密码等。
   - 配置从数据库的唯一标识符（server-id），通常不同于主数据库的标识符。
   - 启用从数据库的复制线程（Replication Thread），该线程会连接到主数据库并获取主数据库的二进制日志。
3. **初始化从数据库**：
   - 在从数据库上执行一个初始化复制的操作，通常是执行`CHANGE MASTER TO`语句，告诉从数据库如何连接到主数据库。
4. **开始复制**：
   - 从数据库连接到主数据库，并开始获取主数据库的二进制日志。
   - 从数据库将主数据库的数据更改操作应用到自己的数据上，从而与主数据库保持一致。
5. **监控和维护**：
   - 定期监控主从同步状态，确保复制进程正常运行。
   - 在主数据库上进行备份和维护操作时，需要小心处理，以免影响复制进程。

注意事项：

- 主从同步是异步的，从数据库的数据可能略有滞后于主数据库。
- 在某些情况下，可能会出现主从同步的延迟，特别是在高负载情况下。
- 主从同步的配置和管理需要小心，以确保数据的一致性和可用性。

主从同步是数据库系统中的一个关键特性，可用于提高数据可用性、故障恢复和负载均衡。不同的数据库管理系统（如MySQL、PostgreSQL、Oracle等）提供了类似但稍有不同的配置和管理方式。

## MySQL存储结构

MySQL的存储结构涉及多个层次和组件，每个组件都有不同的作用和功能。以下是MySQL的主要存储结构：

1. **服务器层（Server Layer）**：
   - 这是MySQL的核心，包括了SQL解析、查询优化、缓存管理、安全认证、客户端连接管理等。服务器层处理来自客户端的SQL查询请求，协调数据的读写操作。
2. **存储引擎层（Storage Engine Layer）**：
   - 存储引擎是MySQL的重要组成部分，负责实际的数据存储和检索。MySQL支持多种存储引擎，如InnoDB、MyISAM、Memory、等等。每个存储引擎具有不同的特性和适用场景。不同表可以选择不同的存储引擎。
3. **表（Table）**：
   - 数据库中的数据以表的形式组织，每个表包含若干行（记录）和若干列（字段）。表是MySQL中数据存储的基本单位。
4. **索引（Index）**：
   - 索引用于加速数据检索操作。MySQL使用B-tree索引等数据结构来维护索引信息。索引可以是表的主键索引、唯一索引、全文索引等。
5. **数据文件（Data Files）**：
   - MySQL数据库的数据存储在数据文件中。每个表通常对应一个或多个数据文件，这些文件包含了表的数据行。不同存储引擎可能以不同的方式组织数据文件。
6. **日志文件（Log Files）**：
   - MySQL使用多种类型的日志文件，包括二进制日志（Binary Log）、错误日志、慢查询日志、事务日志（InnoDB存储引擎使用的日志）等。这些日志用于记录和恢复数据的更改、错误信息和性能分析。
7. **系统表空间（System Tablespace）**：
   - InnoDB存储引擎使用系统表空间来存储系统元数据，如表结构、索引信息等。
8. **用户表空间（User Tablespace）**：
   - InnoDB存储引擎可以使用用户表空间来存储用户数据，允许用户将表和索引分散到不同的表空间中。
9. **缓冲池（Buffer Pool）**：
   - InnoDB存储引擎维护一个缓冲池，用于缓存热数据，以加速数据的读取操作。缓冲池通常位于内存中。
10. **日志缓冲（Log Buffer）**：
    - InnoDB存储引擎使用日志缓冲来缓存事务日志，以提高事务的持久性。

# 二面

## 多态和多态底层实现

多态性是面向对象编程的一个特性，它允许不同的派生类对象通过基类指针或引用来调用相同的虚函数，从而实现不同的行为。多态性有助于实现代码的可扩展性和灵活性。

C++中的多态通过虚函数和继承来实现。具体来说，实现多态性的关键是使用虚函数：

1. 在基类中声明虚函数：在基类中定义虚函数，使用 `virtual` 关键字，这将使该函数成为虚函数，允许它在派生类中被重写。
2. 在派生类中重写虚函数：派生类可以重写虚函数以提供特定于派生类的实现。
3. 使用基类指针或引用调用虚函数：通过使用基类指针或引用来引用派生类对象，可以实现多态。

底层实现方面，C++编译器通常使用虚函数表（vtable）来管理虚函数的调用。虚函数表是一个数据结构，其中包含了每个类的虚函数指针。每个类的对象都包含一个指向相应虚函数表的指针，这样在运行时可以根据对象的实际类型来调用正确的虚函数。

## 如何实现一个hash表

1. 哈希函数（Hash Function）：哈希函数用于将键映射到哈希表的索引位置。它应该能够将不同的键均匀地分散在哈希表中。
2. 冲突处理：由于不同的键可能映射到相同的索引位置，所以需要一种方法来处理这种情况。常见的冲突处理方法包括链地址法（Chaining）和开放寻址法（Open Addressing）。
3. 数组或链表：在哈希表中，通常使用数组或链表来存储键值对。如果采用链地址法，每个索引位置会有一个链表，存储映射到该位置的键值对。

```
#include <iostream>
#include <vector>
#include <list>

class HashTable {
private:
    static const int TABLE_SIZE = 100;
    std::vector<std::list<std::pair<int, std::string>>> table;

    // 哈希函数：简单取余
    int hash(int key) {
        return key % TABLE_SIZE;
    }

public:
    HashTable() {
        table.resize(TABLE_SIZE);
    }

    // 插入键值对
    void insert(int key, const std::string& value) {
        int index = hash(key);
        table[index].push_back(std::make_pair(key, value));
    }

    // 查找键对应的值
    std::string search(int key) {
        int index = hash(key);
        for (const auto& pair : table[index]) {
            if (pair.first == key) {
                return pair.second;
            }
        }
        return "Key not found";
    }

    // 删除键值对
    void remove(int key) {
        int index = hash(key);
        auto& linked_list = table[index];
        for (auto it = linked_list.begin(); it != linked_list.end(); ++it) {
            if (it->first == key) {
                linked_list.erase(it);
                break;
            }
        }
    }
};
```

## TCP和UDP的区别

TCP（传输控制协议）和UDP（用户数据报协议）是两种不同的传输层协议，用于在计算机网络中传输数据。它们之间的主要区别包括以下几个方面：

1. 连接导向性：
   - TCP是面向连接的协议，它在通信之前建立连接，确保数据可靠传输，然后在通信结束后关闭连接。TCP提供错误检测、重传丢失的数据、按顺序传递数据等功能，适用于需要可靠传输的应用，如网页浏览、电子邮件等。
   - UDP是面向无连接的协议，它不建立连接，数据包之间相互独立。UDP不提供数据可靠性保证，但具有较低的延迟和较小的开销。它适用于实时应用，如音频和视频流、在线游戏等。
2. 可靠性：
   - TCP确保数据的可靠性，通过确认机制和重传机制来处理数据包的丢失或损坏。这使得TCP适用于需要数据完整性的应用。
   - UDP不提供数据包的可靠性保证，它不会重传丢失的数据包，因此在传输中数据包可能会丢失或乱序。
3. 数据包顺序：
   - TCP确保数据包按照发送的顺序被接收，即使它们在传输过程中乱序到达，TCP会对它们进行重新排序。
   - UDP不保证数据包的顺序，因此接收端可能会以不同的顺序接收数据包。
4. 阻塞：
   - TCP连接在通信时可能会发生阻塞，直到连接建立或数据传输完成。这会增加延迟。
   - UDP没有连接建立的阻塞，数据包可以立即发送，降低了延迟。
5. 头部开销：
   - TCP头部相对较大，包含序列号、确认号、窗口大小等信息，导致较大的开销。
   - UDP头部较小，开销较小。

总之，TCP和UDP适用于不同类型的应用和场景。选择哪种协议取决于应用程序的要求，包括数据可靠性、延迟、开销等因素。

## tcp可靠传输靠哪些实现

1. 序号和确认：
   - TCP使用序号（Sequence Number）来对数据包进行编号，发送方将数据包按顺序编号并发送，接收方根据序号将数据包重新排序。这确保了数据包按正确的顺序到达接收方。
   - TCP还使用确认号（Acknowledgment Number）来通知发送方已成功接收的数据包。如果发送方未收到确认，它会重新传输数据包。
2. 数据包重传：
   - TCP使用数据包重传机制来应对数据包的丢失。如果发送方未收到确认，它会重新发送相应的数据包，直到得到确认为止。
3. 流量控制：
   - TCP使用滑动窗口（Sliding Window）机制来进行流量控制。接收方通过确认中的窗口大小告知发送方可以接收的数据量。发送方根据窗口大小来控制发送的数据量，以避免过载接收方。
4. 拥塞控制：
   - TCP通过拥塞窗口控制来应对网络拥塞情况。当网络拥塞时，TCP会减小发送速率，以减轻网络负载，然后逐渐增加发送速率，以寻找适当的发送速率。
5. 超时重传：
   - 如果一个数据包未在一定时间内得到确认，TCP会将它标记为超时，然后重传。这确保了即使某些数据包在传输过程中丢失，它们最终能够被成功传送。
6. 连接建立和终止：
   - TCP使用三次握手来建立连接，确保双方都知道彼此可以通信。在连接终止时，TCP使用四次挥手来优雅地关闭连接，确保数据的完整传输。

## UDP包过大会有什么问题

1. 分片：如果UDP数据包超过网络链路的最大传输单元（MTU），它将被分割成更小的片段（分片）。这些分片将在网络上传输，然后在目标端重新组装成原始数据包。分片过程会增加处理开销和网络传输时间，因此通常希望避免分片。
2. 延迟：大型UDP数据包可能会导致网络传输延迟增加，因为较大的数据包需要更长时间才能在网络上传输完成。这可能会影响实时应用程序的性能，如实时音视频流。
3. 丢包：UDP本身不提供可靠性保证，因此大型UDP数据包在传输过程中更容易受到丢包的影响。丢失部分数据包可能导致接收端无法完整地接收消息。

4. 网络拥塞：发送大型UDP数据包可能会占用较多的带宽，导致网络拥塞。这会影响其他数据流的传输性能，尤其是在网络上存在高负载时。

5. 内存和处理开销：接收端需要足够的内存来接收和处理大型UDP数据包。如果数据包过大，可能会导致内存不足或需要更多的处理时间来处理数据

## tcp客户端和服务端建立长连接，客户端异常退出，会有什么影响

1. 半开连接：如果客户端异常退出，服务端可能仍保持一个半开连接状态。在这种情况下，服务端不再能够接收来自客户端的数据，但服务端可以继续向客户端发送数据。这可能导致服务端的数据传输失败，因为客户端不再响应。
2. 资源泄漏：客户端异常退出后，服务端可能仍然保持一段时间的连接状态，这可能会导致资源泄漏。服务器需要等待操作系统的连接超时或通过应用程序主动检测并关闭这些半开连接，以释放资源。
3. 应用程序行为：应用程序需要处理客户端异常退出的情况。服务端应用程序可能会检测到客户端连接的异常终止，并采取适当的措施，例如清理资源、记录日志或通知管理员。
4. 客户端重连：客户端异常退出后，如果有必要，它可以尝试重新建立连接。这通常需要在客户端应用程序中实现，以确保服务的可用性。

## 进程异常退出，操作系统应该怎么做

1. 终止进程：首要任务是终止异常退出的进程，以防止其继续运行导致更多问题。操作系统会向进程发送一个终止信号（如`SIGKILL`），以强制终止进程的执行。
2. 释放资源：操作系统会回收与异常退出进程相关的资源，包括内存、文件描述符、套接字等。这确保了资源不会被浪费或泄漏。
3. 生成核心转储文件（可选）：在某些情况下，操作系统可以生成核心转储文件，该文件包含了进程在异常退出之前的内存状态和调用栈信息。这有助于开发人员分析问题的根本原因。
4. 记录事件：操作系统通常会记录事件日志，以便系统管理员或开发人员能够查看异常退出的原因和详细信息。这有助于故障排除和问题诊断。
5. 通知父进程（如果适用）：如果异常退出的进程是由另一个父进程（通常是一个父进程创建的子进程）启动的，操作系统可以向父进程发送相应的信号或通知，以便父进程能够采取适当的行动。

## linux服务器上跑了很对进程，物理内存越来越少，对服务器有什么影响

1. **性能下降**: 当物理内存不足时，Linux操作系统将不得不频繁进行内存交换（swap），将部分进程的内存数据转移到交换空间（磁盘上），以腾出物理内存供其他进程使用。这会导致性能急剧下降，因为从磁盘读取和写入数据比从内存中操作数据慢得多。
2. **响应时间延迟**: 内存紧缺会导致进程响应时间增加，因为进程需要等待数据从交换空间加载到内存中才能执行。这将导致系统响应时间变得不稳定，用户可能会感到延迟。
3. **死锁和进程终止**: 当物理内存不足时，Linux内核可能会终止一些进程以释放内存。这可能会导致进程死锁或数据丢失。
4. **严重性能问题**: 如果内存不足导致交换过于频繁，系统性能问题可能会变得严重，最终可能导致服务器宕机或不可用。

为了解决这些问题，可以考虑以下措施：

- 优化服务器配置，增加物理内存。
- 分析并优化进程，确保只运行必要的进程，并限制它们的内存使用。
- 使用Linux内核参数来调整内存管理策略，以降低内存压力。
- 使用内存交换策略来最小化性能下降。
- 使用监控工具来及时发现内存问题并采取措施。
- 在必要时重启服务器以释放内存和恢复性能。

## 物理内存不足，服务器，系统会怎么做

1. **内存交换（Swapping）**：操作系统会将不活动的内存页面移出物理内存，存储到硬盘上的交换文件中，以释放物理内存空间供其他进程使用。这可以缓解内存不足的情况，但会导致性能下降，因为从磁盘读取数据的速度比从内存读取慢。
2. **终止进程**：如果内存不足且没有足够的页面可以交换，操作系统可能会终止某些进程以释放内存。通常，操作系统会选择终止那些消耗大量内存且较不重要的进程。这可能会导致进程中断和数据丢失。
3. **内存压缩**：一些现代操作系统具有内存压缩功能，可以将内存中的数据进行压缩，以节省内存空间。这可以减轻内存不足问题。
4. **虚拟内存**：操作系统可以使用虚拟内存技术，将部分数据从物理内存移到硬盘上的虚拟内存。这样可以扩展可用的内存空间，但也会降低性能。
5. **警告和错误处理**：操作系统通常会生成警告或错误消息，提示系统管理员或用户内存不足的问题，以便及时采取措施来解决。

## 如何实现redis的高并发

1. **硬件升级**：确保服务器硬件足够强大以处理高并发负载。这包括增加CPU核数、增加内存容量、使用快速的固态硬盘（SSD）等。
2. **负载均衡**：使用负载均衡器来分发请求到多个Redis实例，以确保负载均衡，提高性能和可用性。
3. **集群部署**：将Redis部署为集群，以分散数据和请求，减轻单一Redis实例的负载。
4. **读写分离**：将读和写操作分开，读操作可以由多个从节点处理，减轻主节点的负载。这通常通过配置Redis复制实现。
5. **数据分片**：将数据分成多个片段，每个片段由不同的Redis实例管理。这可以提高并发性，但需要更复杂的应用程序逻辑。
6. **连接池**：使用连接池来管理Redis连接，减少连接的创建和销毁开销。
7. **优化命令**：选择合适的Redis命令和数据结构，以最小化数据传输和提高性能。
8. **持久化策略**：根据需求选择合适的持久化策略，如RDB快照和AOF日志，以平衡性能和数据安全。
9. **缓存**：使用Redis作为缓存，将频繁访问的数据缓存起来，减轻后端数据库的负载。
10. **监控和调优**：使用监控工具来监视Redis性能，及时发现问题并进行性能调优。
11. **合理设计数据模型**：根据应用需求和查询模式来设计合理的数据模型，以降低复杂查询的成本。
12. **并发控制**：使用Redis的事务和乐观锁等机制来实现并发控制，避免竞态条件和数据不一致。

## epoll底层如何实现处理海量请求

`epoll` 的底层实现主要依赖于以下几个关键组件：

1. **红黑树（Red-Black Tree）**：`epoll` 使用一个红黑树来管理所有的文件描述符。这个树允许快速的插入、删除和查找操作。文件描述符上的事件发生时，它会被插入到红黑树中。
2. **双链表（Doubly Linked List）**：为了提高效率，`epoll` 使用双链表来管理准备好的文件描述符，即那些可以进行读写操作的描述符。
3. **事件结构（Event Structure）**：`epoll` 使用事件结构来表示需要监视的文件描述符以及它们所关联的事件类型（例如，读、写、错误等）。当一个文件描述符上的事件发生时，`epoll` 会生成一个事件结构。
4. **等待队列**：等待队列是一个列表，用于存储等待事件的进程或线程。当一个文件描述符上的事件发生时，`epoll` 会唤醒等待队列中的进程或线程，以便它们可以处理事件。

`epoll` 的工作流程如下：

1. 用户程序通过 `epoll_create` 创建一个 `epoll` 实例。
2. 用户程序使用 `epoll_ctl` 向 `epoll` 实例注册需要监视的文件描述符和事件类型。
3. `epoll` 内部将这些文件描述符添加到红黑树中，并等待事件发生。
4. 当有事件发生时，`epoll` 将相应的事件结构插入到双链表中。
5. `epoll_wait` 函数被调用，它会阻塞，直到有事件发生。
6. 当 `epoll_wait` 返回时，用户程序可以遍历双链表，处理准备好的文件描述符上的事件。
7. 用户程序可以重复注册、删除、或修改文件描述符和事件类型，以动态调整监视的对象。

假设我们有一个简单的 Web 服务器，它需要处理来自客户端的 HTTP 请求。服务器监听端口，等待客户端连接。一旦客户端连接，服务器需要处理请求并返回响应。

1. 等待队列中的任务：
   - 等待队列中的任务是操作系统的事件处理任务。在这种情况下，等待队列中的任务包括等待客户端连接的任务（如等待新连接的任务）以及等待套接字上的读取请求的任务（如等待 HTTP 请求的任务）。
2. 用户自己编写的线程池中的任务：
   - 用户自己编写的线程池中的任务是应用程序的业务逻辑。对于我们的 Web 服务器示例，线程池中的任务包括：
     - 解析 HTTP 请求
     - 处理请求（如获取请求的资源）
     - 生成 HTTP 响应
     - 发送响应到客户端
3. 关系：
   - 当等待队列中的任务（等待新连接的任务或等待 HTTP 请求的任务）触发事件时，通常会调用用户自己编写的回调函数（例如，当有新的客户端连接时，会触发连接回调函数；当有 HTTP 请求到达时，会触发请求处理回调函数）。
   - 这些回调函数会被线程池中的线程执行。线程池中的线程执行用户自己编写的任务，处理请求、生成响应，并将响应发送回客户端。

可以将等待队列中的任务看作是事件分发器，它们等待某些事件的发生（例如，新的客户端连接或数据可读事件），然后触发用户编写的回调函数（处理连接或数据），这些回调函数由线程池中的线程执行。这种架构允许服务器异步处理请求，有效地利用了多线程来提高性能和并发处理能力。

## epoll为什么使用红黑树

1. **高效的事件查找和管理**：红黑树是一种自平衡的二叉搜索树，它具有快速的查找和插入操作。这使得 `epoll` 可以高效地管理大量的文件描述符，并快速查找出哪些文件描述符已经准备好进行读写操作。
2. **非阻塞 I/O 模型**：`epoll` 通常与非阻塞 I/O 模型一起使用，红黑树可以帮助 `epoll` 追踪哪些文件描述符已经准备好进行读写操作，而不需要阻塞等待。这是一种异步事件驱动的方式，允许服务器同时管理多个连接，而不会被一个阻塞的连接影响。
3. **支持水平触发和边缘触发**：`epoll` 支持两种触发模式，包括水平触发（Level-Triggered）和边缘触发（Edge-Triggered）。红黑树的设计能够满足这两种触发模式的需求，使得 `epoll` 在不同应用场景下更加灵活。
4. **动态管理**：`epoll` 允许动态地添加或删除文件描述符，而红黑树的动态性质使其适合用于这种用途。

## 就绪队列的作用

1. **标识就绪事件**：就绪队列存储了那些已准备好执行 I/O 操作的文件描述符，这些文件描述符上发生了特定的事件，如可读或可写等。操作系统通过 epoll 监听这些事件，并将就绪的文件描述符放入就绪队列。
2. **提高效率**：就绪队列的存在提高了 I/O 操作的效率。相比于传统的同步 I/O 模型，epoll 使用异步的方式，只有当文件描述符准备好时才会进行 I/O 操作，避免了不必要的阻塞。
3. **减少系统开销**：epoll 的就绪队列使操作系统能够高效地管理大量的文件描述符。在传统的多线程或多进程模型中，可能需要为每个文件描述符都创建一个线程或进程，而 epoll 允许通过少量线程来管理大量文件描述符，从而减少了系统开销。
4. **非阻塞调度**：epoll 采用非阻塞的调度方式，因此文件描述符在就绪队列中等待时不会阻塞线程或进程，而是在需要时才被调度执行，提高了并发性。
5. **支持边缘触发**：epoll 支持边缘触发（Edge-Triggered）模式，这意味着只有在状态发生变化时，文件描述符才会被添加到就绪队列，而不是在状态一直保持的情况下反复触发。

## 30个中文关键词，一篇文本文档，统计文本文档中出现这中文关键词的次数

```
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <vector>

int main() {
    // 定义中文关键词列表
    std::vector<std::string> keywords = {"关键词1", "关键词2", "关键词3", "关键词4"};

    // 打开文本文档
    std::ifstream file("your_text_document.txt");
    if (!file.is_open()) {
        std::cerr << "无法打开文件" << std::endl;
        return 1;
    }

    // 初始化关键词计数字典
    std::map<std::string, int> keywordCount;
    for (const std::string& keyword : keywords) {
        keywordCount[keyword] = 0;
    }

    // 逐行读取文本，统计关键词出现次数
    std::string line;
    while (std::getline(file, line)) {
        for (const std::string& keyword : keywords) {
            size_t pos = 0;
            int count = 0;
            while ((pos = line.find(keyword, pos)) != std::string::npos) {
                count++;
                pos += keyword.length();
            }
            keywordCount[keyword] += count;
        }
    }

    // 打印每个关键词的出现次数
    for (const auto& entry : keywordCount) {
        std::cout << "关键词 \"" << entry.first << "\" 出现次数: " << entry.second << std::endl;
    }

    file.close();
    return 0;
}
```

