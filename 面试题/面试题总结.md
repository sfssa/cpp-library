### Linux系统分区了解哪一些

1. **Linux系统分区：**

   - **根分区（/）：** 根分区包含了Linux操作系统的核心文件和目录，它是文件系统的顶级目录。
   - **/home 分区：** 通常用于存储用户的个人文件和数据。
   - **/boot 分区：** 包含引导加载程序和内核文件。
   - **/var 分区：** 存储可变数据，如日志文件、数据库文件等。
   - **/tmp 分区：** 用于存储临时文件。
   - **/usr 分区：** 包含用户安装的应用程序和系统工具。
   - **/etc 分区：** 包含系统配置文件。
   - **swap 分区：** 用作虚拟内存交换空间。

   Linux系统分区是用于组织磁盘上的存储空间，以便在操作系统中存储文件和数据。

### 进程、线程和协程

|          | 进程                                                         | 线程                                               | 协程                                                         |
| -------- | ------------------------------------------------------------ | -------------------------------------------------- | ------------------------------------------------------------ |
| 定义     | 资源分配和拥有的基本单位                                     | 程序执行的基本单位                                 | 用户态的轻量级线程，线程内部调度的基本单位                   |
| 切换情况 | 进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置 | 保存和设置程序计数器、少量寄存器和栈的内容         | 先将寄存器上下文和栈保存，等切换回来的时候再进行恢复         |
| 切换者   | 操作系统                                                     | 操作系统                                           | 用户                                                         |
| 切换过程 | 用户态->内核态->用户态                                       | 用户态->内核态->用户态                             | 用户态(没有陷入内核)                                         |
| 调用栈   | 内核栈                                                       | 内核栈                                             | 用户栈                                                       |
| 拥有资源 | CPU资源、内存资源、文件资源和句柄等                          | 程序计数器、寄存器、栈和状态字                     | 拥有自己的寄存器上下文和栈                                   |
| 并发性   | 不同进程之间切换实现并发，各自占有CPU实现并行                | 一个进程内部的多个线程并发执行                     | 同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理 |
| 系统开销 | 切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大 | 切换时只需保存和设置少量寄存器内容，因此开销很小   | 直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快 |
| 通信方面 | 进程间通信需要借助操作系统                                   | 线程间可以直接读写进程数据段(如全局变量)来进行通信 | 共享内存、消息队列                                           |

1、进程是资源分配的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序

2、线程是资源调度的基本单位，也是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。多提一句：协程是用户态的轻量级线程，线程内部调度的基本单位

### git merge和git rebase的区别

1. **git merge：**

   - 合并方式：`git merge` 将一个分支的更改合并到另一个分支。合并后的分支历史将保留原始的分支结构，新的合并提交将被创建。
   - 合并提交：`git merge` 会创建一个新的合并提交，该提交有两个或多个父提交，分别表示被合并的分支的提交。这些合并提交会在分支历史中显示，以反映合并操作。
   - 分支历史：分支历史中保留了合并的详细信息，包括合并的时间点和合并分支。

2. **git rebase：**

   - 合并方式：`git rebase` 重新定义了分支历史。它将一个分支的更改放在另一个分支的最顶端，看起来就像是按顺序开发的。它会把提交从一个分支移到另一个分支上，而不会创建合并提交。
   - 合并提交：`git rebase` 不会创建合并提交，因为它将提交线性排列，而不会保留分支的原始结构。
   - 分支历史：`git rebase` 会改写分支历史，使之看起来更加线性和干净，但也可能会丢失分支的详细合并历史。

   ![image-20231015180709537](C:\Users\16645\AppData\Roaming\Typora\typora-user-images\image-20231015180709537.png)

   git merge根据共同祖先3和两个分支最新的提交6和5的信息来完成一次新的提交，保留原有分支的结构。

   ![image-20231015180858687](C:\Users\16645\AppData\Roaming\Typora\typora-user-images\image-20231015180858687.png)

git rebase类似于一种嫁接，将分支的提交插入到本分支，并且生成新的提交6`。

### C++中的extern关键字，new和malloc的区别

1. **extern关键字：**
   - `extern` 是C++中的关键字，用于指示一个变量、函数或对象是在其他文件中声明或定义的，而不是在当前文件中。它用于告诉编译器在链接时在其他文件中查找该标识符的定义。
   - `extern` 变量通常用于声明全局变量，函数或对象，以便在多个源文件中共享它们的定义。通常，`extern` 声明出现在头文件中，而实际的定义出现在一个或多个源文件中。
2. **new和malloc的区别：**
   - `new` 和 `malloc` 都用于动态分配内存，但它们有以下区别：
   - `new` 是C++的运算符，而 `malloc` 是C标准库函数。`new` 在分配内存后会调用对象的构造函数（如果有的话），而 `malloc` 不会。这意味着使用 `new` 可以分配动态对象，并执行对象的初始化。
   - `new` 返回一个指向动态分配的对象的指针，而 `malloc` 返回一个指向内存块的指针。因此，你可以使用 `new` 来分配动态对象，而使用 `malloc` 分配未初始化的内存块。
   - `new` 和 `delete` 必须成对使用，用于动态对象的分配和释放。类似地，`malloc` 和 `free` 必须成对使用，用于内存块的分配和释放。
   - `new` 和 `delete` 运算符提供了更强大的类型安全性，因为它们与C++的对象和类一起工作，而 `malloc` 和 `free` 主要用于分配和释放内存块，不考虑对象的构造和析构。

综上所述，`new` 和 `malloc` 在C++中主要用于内存分配，但它们的行为和用法略有不同。通常情况下，建议在C++中使用 `new` 和 `delete` 来动态分配和释放对象，因为它们提供了更好的类型安全性和对象构造支持。

### 数组和链表的区别？

1. **内存组织方式**：
   - **数组**：数组在内存中以连续的块存储元素，每个元素占用相同大小的内存。
   - **链表**：链表中的元素（节点）可以分散存储在内存中，每个节点包含指向下一个节点的指针。
2. **插入和删除操作**：
   - **数组**：在插入或删除元素时，需要移动其他元素以维持连续性，这可能需要较长的时间。在数组中插入或删除元素的时间复杂度为 O(n)。
   - **链表**：在链表中插入或删除元素只需修改节点的指针，而不需要移动其他元素。在链表中插入或删除元素的时间复杂度为 O(1)。
3. **随机访问**：
   - **数组**：由于元素在内存中是连续存储的，可以通过索引进行快速随机访问，时间复杂度为 O(1)。
   - **链表**：需要遍历链表从头部开始才能访问特定位置的元素，时间复杂度为 O(n)。
4. **空间复杂度**：
   - **数组**：通常占用更多的内存，因为它需要预先分配固定大小的内存块。
   - **链表**：可以更加灵活地使用内存，因为它只在需要时分配节点的内存。
5. **动态大小**：
   - **数组**：通常需要重新分配内存和复制元素来调整大小，这可能导致开销。
   - **链表**：可以更容易地增加或减少元素，无需复制现有元素。

### 说一下智能指针有哪些？使用场景？

智能指针是C++中的智能内存管理工具，包括 `shared_ptr`、`unique_ptr` 和 `weak_ptr`。它们的使用场景包括避免内存泄漏、管理动态分配的内存、在多个指针之间共享对象、避免悬挂指针等。`shared_ptr` 用于多个指针共享拥有权，`unique_ptr` 用于独占拥有权，而 `weak_ptr` 用于弱引用，通常用于解决循环引用问题。

### C++的类型转换和使用场景？

C++提供了多种类型转换操作，包括静态转换、动态转换、`const` 转换等。这些类型转换操作用于将一种数据类型转换为另一种。使用场景取决于具体需求，例如在父子类之间进行多态类型转换、将指针从非 `const` 转换为 `const`，或者将数据从一种基本数据类型转换为另一种。

### 说一下什么是进程？线程？二者的联系？

- 进程是计算机中正在运行的程序的实例，拥有独立的内存空间和资源。它们之间相互隔离。
- 线程是进程内的执行单元，共享进程的内存空间和资源。它们可以协同工作，更轻量级。

**联系**：多个线程可以存在于同一进程中，共享进程的资源，但线程之间需要进行同步来避免竞争条件和资源冲突。

### 解决哈希冲突的方法有哪些？

- 链地址法（Separate Chaining）：将哈希冲突的元素存储在同一桶（链表、数组等）中。
- 开放寻址法（Open Addressing）：在哈希冲突时，寻找下一个可用的位置存储元素。
- 建立更好的哈希函数：通过改进哈希函数来减少冲突的概率。
- 二次哈希法。

### 讲一下虚函数实现的原理？

常用形式是用基类指针指向子类对象，在具体执行时会调用子类重写的函数体。

如果一个类有虚函数，那么在编译器编译完成这个类时会生成一个虚函数表，这个表中包含虚函数和该函数的入口地址。每个对象都有一个虚表指针，在构造函数中初始化这个指针指向虚函数表。当含有虚函数的基类派生出派生类后，会复制一份父类的虚函数表，然后如果检查到派生类对基类的虚函数进行了重写，那么就把函数的入口地址换成重写后的地址。在运行时，根据对象的类型和指向虚函数表的指针来调用正确的虚函数。

### 讲一下select 和epoll的区别？

select采用位图的方法，由于Linux内核规定一个进程最大允许打开的文件描述符的数目是1024（可以修改，重新编译内核），因此准备一个1024大小的内核，先将位图都设置为0，然后遍历，将要监听的位置设为1，将位图复制到内核态，由内核态来监听，传递的时候传递需要监听的文件描述符的最大值+1，然后内核遍历检查对应的位置是否发生变化，当发生变化后设置位图，将位图复制回用户态，用户态再次遍历检查触发的事件后进行对应的处理，当需要再次使用时，再次将位图的所有位置设置为0；

**问题**

- 需要频繁的将位图复制到内核态和用户态；
- 文件描述符大小受限；
- 需要多次遍历；
- 位图每次使用前都要置为0；

epoll采用红黑树的方式保存文件描述符，第一个就是采用自定义的结构体，因此没有容量限制；其次将事件注册表交由内核来维护，不需要频繁的在内核态和用户态复制操作；事件注册表有一个队列，当有文件描述符发生事件时将对应的文件描述符放到这个队列中，用户态直接访问这个队列就可以。	